<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container-fluid">
        <div class="row">
            <a href='index.html' class='back-link-arrow'><img src='imgages/—Pngtree—left arrow flat multi color_3777299.png' class='back-arrow'></a>
            <div class="col-3 sidebar">
                <h4> Введення </h4>
                <a href="#entering"> Введенння в JavaScript </a>
                <a href="#specifications"> Довідники і спеціфікації </a>
                <a href="#codeEditors"> Редактор коду </a>
                <a href="#developersConsole"> Консоль розробника </a>
                <h4> Основи JavaScript </h4>
                <a href='#helloWorld'> Hello world </a>
                <a href='#codeStructure'> Структура коду </a>
                <a href='#useStrict'> Суворий режим - "use strict" </a>
                <a href='#variables'> Змінні </a>
                <a href='#dataTypes'> Типи даних </a>
                <a href='#dataTransformation'> Перетворення типів </a>
                <a href='#baseMatematicOperations'> Базові оператори, математика </a>
                <a href='#comparisonOperators'> Оператори порівняння </a>
                <a href='#condition'> Умовне розгалуження: if, '?' </a>
                <a href='#logicalOperators'> Логічні оператори </a>
                <a href='#functions'> Функції </a>
                <a class='h3' href='#control-tasks'>Контрольні питання:</a>
            </div>
            <div class="col-9 main-content">
                <h3 id='entering'>Введення в JavaScript </h3>
                <div itemprop="articleBody">
                    <p>Давайте подивимося, що такого особливого в JavaScript, чого можна досягти за його допомогою і які інші технології добре з ним працюють. </p>
                    <h2><a class="main__anchor" name="chto-takoe-javascript" href="#chto-takoe-javascript"> Що таке JavaScript? </a> </h2>
                    <p>Спочатку <em> JavaScript </em> був створений, щоб <em> «зробити веб-сторінки живими» </em>. </p>
                    <p>Програми на цій мові називаються <em> скриптами </em>. Вони можуть вбудовуватися в HTML і виконуватися автоматично при завантаженні веб-сторінки. </p>
                    <p>Скрипти поширюються і виконуються, як простий текст. Їм не потрібна спеціальна підготовка або компіляція для запуску. </p>
                    <p>Це відрізняє JavaScript від іншої мови - <a href="https://ru.wikipedia.org/wiki/Java"> Java </a>. </p>
                    <div class="important important_smart">
                        <div class="important__header"><span class="important__type"> Чому <u>Java </u> Script? </span> </div>
                        <div class="important__content">
                            <p> Коли JavaScript створювався, у нього було інше ім'я - «LiveScript». Однак, мова Java був дуже популярний в той час, і було вирішено, що позиціювання JavaScript як «молодшого брата» Java буде корисно. </p>
                            <p>З часом JavaScript став повністю незалежним мовою зі своєю власною специфікацією, яка називається <a href="http://ru.wikipedia.org/wiki/ECMAScript"> ECMAScript </a>, і зараз не має ніякого відношення до Java . </ p>
                        </div>
                    </div>
                    <p> Сьогодні JavaScript може виконуватися не тільки в браузері, а й на сервері або на будь-якому іншому пристрої, який має спеціальну програму, що називається <a href="https://ru.wikipedia.org/wiki/%D0%94% D0% B2% D0% B8% D0% B6% D0% BE% D0% BA_JavaScript ">« движком »JavaScript </a>. </p>
                    <p> У браузера є власний движок, який іноді називають «віртуальна машина JavaScript». </p>
                    <p> Різні движки мають різні «кодові імена». Наприклад: </p>
                    <ul>
                        <li><a href="https://ru.wikipedia.org/wiki/V8_(%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA_JavaScript)"> V8 </a> - в Chrome і Opera. </li>
                        <li><a href="https://ru.wikipedia.org/wiki/SpiderMonkey"> SpiderMonkey </a> - в Firefox. </li>
                        <li> ... Ще є «Trident» і «Chakra» для різних версій IE, «ChakraCore» для Microsoft Edge, «Nitro» і «SquirrelFish» для Safari і т.д. </li>
                    </ul>
                    <p>Ці назви корисно знати, так як вони часто використовуються в статтях для розробників. Ми теж будемо їх використовувати. Наприклад, якщо «функціональність X підтримується V8», тоді «Х», швидше за все, працює в Chrome і Opera. </p>
                    <div class="important important_smart">
                        <div class="important__header">
                            <span class="important__type"> Як працюють двигуни? </span>
                        </div>
                        <div class="important__content">
                            <p> Двигуни складні. Але основи зрозуміти легко. </p>
                            <ol>
                                <li> Двигун (вбудований, якщо це браузер) читає («парсит») текст скрипта. </li>
                                <li> Потім він перетворює («компілює») скрипт в машинну мову. </li>
                                <li> Після цього машинний код запускається і працює досить швидко. </li>
                            </ol>
                            <p>Движок застосовує оптимізації на кожному етапі. Він навіть переглядає скомпільований скрипт під час його роботи, аналізуючи проходять через нього дані, і застосовує оптимізації до машинного коду, покладаючись на отримані знання. В результаті скрипти працюють дуже швидко.</p>
                        </div>
                    </div>
                    <h2>
                        <a class="main__anchor" name="chto-mozhet-javascript-v-brauzere" href="#chto-mozhet-javascript-v-brauzere">Что может JavaScript в браузере?</a>
                    </h2><p>Сучасний JavaScript - це «безпечний» мову програмування. Він не надає низькорівневий доступ до пам'яті або процесору, тому що спочатку був створений для браузерів, які не потребують цього.</p>
                    <p>Можливості JavaScript сильно залежать від оточення, в якому він працює. Наприклад, <a href="https://ru.wikipedia.org/wiki/Node.js"> Node.JS </a> підтримує функції читання / запису довільних файлів, виконання мережевих запитів і т.д.</p>
                    <p>У браузері для JavaScript є все, що пов'язано з маніпулюванням веб-сторінками, взаємодією з користувачем і веб-сервером.</p>
                    <p>Наприклад, в браузері JavaScript может:</p>
                    <ul>
                        <li> Додавати новий HTML-код на сторінку, змінювати існуючий вміст, модифікувати стилі. </li>
                        <li> Реагувати на дії користувача, клацання миші, перемістити вказівник, натискання клавіш. </li>
                        <li> Відправляти мережеві запити на віддалені сервера, завантажувати і завантажувати файли (технології <a href="https://ru.wikipedia.org/wiki/AJAX"> AJAX </a> і <a href="https: / /ru.wikipedia.org/wiki/Comet_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1% 80% D0% BE% D0% B2% D0% B0% D0% BD% D0% B8% D0% B5) "> COMET </a>). </li>
                        <li> Отримувати і встановлювати куки, задавати питання відвідувачеві, показувати повідомлення. </li>
                        <li> Запам'ятовувати дані на стороні клієнта ( «local storage»). </li>
                    </ul>
                    <h2><a class="main__anchor" name="chego-ne-mozhet-javascript-v-brauzere" href="#chego-ne-mozhet-javascript-v-brauzere">Чого НЕ може JavaScript в браузері?</a></h2><p>Можливості JavaScript в браузері обмежені заради безпеки користувача. Мета полягає в запобіганні доступу недобросовісної веб-сторінки до особистої інформації або нанесення шкоди даними користувача.</p>
                    <p>Приклади таких обмежень включають в себе:</p>
                    <ul>
                        <li>
                            <p>JavaScript на веб-сторінці не може читати / записувати довільні файли на жорсткому диску, копіювати їх або запускати програми. Він не має прямого доступу до системних функцій ОС.</p>
                            <p>Сучасні браузери дозволяють йому працювати з файлами, але з обмеженим доступом, і надають його, тільки якщо користувач виконує певні дії, такі як «перетягування» файлу в вікно браузера або його вибір за допомогою тега  <code>&lt;input&gt;</code>.</p>
                            <p>Існують способи взаємодії з камерою / мікрофоном і іншими пристроями, але вони вимагають явного дозволу користувача. Таким чином, сторінка з підтримкою JavaScript не може непомітно включити веб-камеру, спостерігати за тим, що відбувається і відправляти інформацію.</p>
                        </li>
                        <li>
                            <p> Різні вікна / вкладки не знають один про одного. Іноді одне вікно, використовуючи JavaScript, відкриває інше вікно. Але навіть в цьому випадку JavaScript з однієї сторінки не має доступу до іншої, якщо вони прийшли з різних сайтів (з іншого домену, протоколу або порту). </p>
                            <p> Це називається «Політика однакового джерела» (Same Origin Policy). Щоб обійти це обмеження, обидві сторінки повинні погодитися з цим і містити JavaScript-код, який спеціальним чином обмінюється даними. </p>
                            <p> Це обмеження необхідно, знову ж таки, для безпеки користувача. Сторінка <code> https://anysite.com </code>, яку відкрив користувач, не повинна мати доступ до іншої вкладці браузера з URL <code> https://gmail.com </code> і красти інформацію звідти. </p>
                        </li>
                        <li>
                            <p>JavaScript може легко взаємодіяти з сервером, з якого прийшла поточна сторінка. Але його здатність отримувати дані з інших сайтів / доменів обмежена. Хоча це можливо в принципі, для чого потрібно явне згоду (виражене в заголовках HTTP) з віддаленої стороною. Знову ж таки, це обмеження безпеки.</p>
                        </li>
                    </ul>
                    <figure>
                        <div class="image" style="width:566px">
                            <div class="image__ratio" style="padding-top:25px"></div>
                            <object type="image/svg+xml" data="/article/intro/limitations.svg" width="566" height="449" class="image__image">
                                <img src="https://learn.javascript.ru/article/intro/limitations.svg" alt="" width="566" height="449">
                            </object>
                        </div>
                    </figure><p>Подібні обмеження не діють, якщо JavaScript використовується поза браузера, наприклад - на сервері. Сучасні браузери надають плагіни / розширення, за допомогою яких можна запитувати додаткові дозволи.</p>
                    <h2><a class="main__anchor" name="chto-delaet-javascript-osobennym" href="#chto-delaet-javascript-osobennym">Що робить JavaScript особливим?</a></h2><p>Як мінімум, <em>три</em>сильні сторони JavaScript:</p>
                    <div class="balance balance_single">
                        <div class="balance__pluses">
                            <div class="balance__content">
                                <ul class="balance__list">
                                    <li>Полна інтеграція з HTML/CSS.</li>
                                    <li> Прості речі робляться просто. </li>
                                    <li> Підтримується всіма основними браузерами і включений за замовчуванням. </li>
                                </ul>
                            </div>
                        </div>
                    </div> <p> JavaScript - це єдина браузерна технологія, що поєднує в собі всі ці три речі. </p>
                    <p> Ось що робить JavaScript особливим. Ось чому це найпоширеніший інструмент для створення інтерфейсів в браузері. </p>
                    <p> Хоча, звичайно, JavaScript дозволяє робити програми не тільки в браузерах, але і на сервері, на мобільних пристроях і т.п. </p>
                    <h2><a class="main__anchor" name="yazyki-nad-javascript" href="#yazyki-nad-javascript"> Мови «над» JavaScript </a> </h2> <p> Синтаксис JavaScript підходять не під всі потреби. Різні люди хочуть мати різні можливості. </p>
                    <p> Це природно, тому що проекти різні і вимоги до них теж різні. </p>
                    <p> Так, останнім часом з'явилося багато нових мов, які <em> транспіліруются </em> (конвертуються) в JavaScript, перш ніж запустяться в браузері. </p>
                    <p> Сучасні інструменти роблять транспіляцію дуже швидкою і прозорою, фактично дозволяючи розробникам писати код на іншій мові, автоматично перетворюючи його в JavaScript «під капотом». </p>
                    <p> Приклади таких мов: </p>
                    <ul>
                        <li><a href="http://coffeescript.org/">CoffeeScript</a> додає «синтаксичний цукор» для JavaScript. Він вводить більш короткий синтаксис, який дозволяє писати чистий і лаконічний код. Зазвичай таке подобається Ruby-програмістам.</li>
                        <li><a href="http://www.typescriptlang.org/">TypeScript</a> концентрується на додаванні «суворої типізації» для спрощення розробки та підтримки великих і складних систем. Розроблено Microsoft.</li>
                        <li><a href="http://flow.org/">Flow</a> теж додає типізацію, але інакше. Розроблено Facebook.</li>
                        <li><a href="https://www.dartlang.org/">Dart</a> стоїть осібно, бо має власний движок, що працює поза браузера (наприклад, в мобільних додатках). Спочатку був запропонований Google, як заміна JavaScript, але на даний момент необхідна його транспіляція для запуску так само, як для перерахованих вище мов.</li>
                        <li><a href="https://brython.info/">Brython</a> транспілірует Python в JavaScript, що дозволяє писати програми на чистому Python без JavaScript.</li>
                    </ul>
                    <p>Є й інші. Але навіть якщо ми використовуємо один з цих мов, ми повинні знати JavaScript, щоб дійсно розуміти, що ми робимо.</p>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Ітого</a></h2><ul>
                        <li>JavaScript спочатку створювався тільки для браузера, але зараз використовується на багатьох інших платформах.</li>
                        <li>Сьогодні JavaScript займає унікальну позицію в якості самого поширеного мови для браузера, який володіє повною інтеграцією з HTML / CSS.</li>
                        <li>Багато мови можуть бути «транспіліровани» в JavaScript для надання додаткових функцій. Рекомендується хоча б коротко розглянути їх після освоєння JavaScript.</li>
                    </ul>
                </div>
                <h3 id='specifications'>Довідники та спеціфікації</h3>
                <div itemprop="articleBody">
                    <h2><a class="main__anchor" name="spetsifikatsiya" href="#spetsifikatsiya">Спеціфікація</a></h2><p><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">Специфікація ECMA-262</a>містить найглибшу, детальну і формалізовану інформацію про JavaScript. Вона визначає сама мова.</p>
                    <p>Спочатку специфікація може здатися важкуватою для розуміння через занадто формального стилю викладу. Якщо ви шукаєте джерело самої достовірної інформації, то це правильне місце, але вона не для щоденного використання.</p>
                    <p>Нова версія специфікації з'являється щороку. А поки вона не вийшла офіційно, всі бажаючі можуть ознайомитися з поточним чернеткою на <a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>.</p>
                    <p>Щоб почитати про останні можливості, включаючи ті, які «майже в стандарті» (так звані «stage 3 proposals»), відвідайте <a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>.</p>
                    <p>Якщо ви розробляєте під браузери, то існують і інші специфікації, про яких розповідається у <a href="/browser-environment">второй части</a> этого учебника.</p>
                    <h2><a class="main__anchor" name="spravochniki" href="#spravochniki">Довідники</h2><ul>
                        <li>
                            <p><strong>MDN (Mozilla) JavaScript Reference</strong> – це довідник з прикладами та іншою інформацією. Хороший джерело для отримання детальної інформації про функції мови, методах вбудованих об'єктів і так далі. </p>
                            <p> Розташовується за адресою <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference">https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference</a>.</p>
                            <p>Хоча часто замість їх сайту зручніше використовувати який-небудь інтернет-пошуковик, вводячи там запит «MDN [що ви хочете знайти]», наприклад <a href="https://google.com/search?q=MDN+parseInt"> https://google.com/search?q=MDN+parseInt </a> для пошуку інформації про функції <code>parseInt</code>.</p>
                        </li>
                        <li>
                            <p><strong>MSDN</strong> –довідник від Microsoft, що містить багато інформації, в тому числі по JavaScript (який там часто позначається як JScript). Якщо вам потрібно знайти щось специфічне по браузеру Internet Explorer, краще шукати там: <a href="http://msdn.microsoft.com/"> http://msdn.microsoft.com/ </a>. </p>
                            <p> Так само, як і в попередньому випадку, можна використовувати інтернет-пошук, набираючи фрази типу «RegExp MSDN» або «RegExp MSDN jscript».</p>
                        </li>
                    </ul>
                    <h2><a class="main__anchor" name="tablitsy-sovmestimosti" href="#tablitsy-sovmestimosti">Таблиці сумісності </a> </h2> <p> JavaScript - це розвивається мова, в який постійно додається щось нове. </p>
                    <p> Подивитися, які можливості підтримуються в різних браузерах і інших двигунах, можна в наступних джерелах:</p>
                    <ul>
                        <li> <a href="http://caniuse.com"> http://caniuse.com </a> - таблиці з інформацією про підтримку по кожній нагоді мови. Наприклад, щоб дізнатися, які движки підтримують сучасні криптографічні функції, відвідайте: <a href="http://caniuse.com/#feat=cryptography"> http://caniuse.com/#feat=cryptography </a>. </li>
                        <li> <a href="https://kangax.github.io/compat-table"> https://kangax.github.io/compat-table </a> - таблиця з можливостями мови і двигунами, які їх підтримують і не підтримують. </li>
                    </ul>
                    <p> Всі ці ресурси корисні в щоденній роботі програміста, так як вони містять цінну інформацію про можливості використання мови, їх підтримки і так далі. </p>
                    <p> Будь ласка, запам'ятайте ці посилання (або посилання на цю сторінку) на випадок, коли вам потрібна детальна інформація про який-небудь конкретної можливості JavaScript. </p>
                </div>
                <h3 id='codeEditors'> Редактор коду </h3>
                <div itemprop="articleBody">
                    <p> Більшу частину свого робочого часу програмісти проводять в редакторах коду. </p>
                    <p> Є два основних типи редакторів: IDE і «легкі» редактори. Багато хто використовує по одному інструменту кожного типу. </p>
                    <h2> <a class="main__anchor" name="ide" href="#ide"> IDE </a> </h2> <p> Терміном <a href="https://ru.wikipedia.org/ wiki / Integrated_development_environment "> IDE </a> (Integrated Development Environment,« інтегроване середовище розробки ») називають потужні редактори з безліччю функцій, які працюють в рамках цілого проекту. Як видно з назви, це не просто редактор, а щось більше. </p>
                    <p> IDE завантажує проект (який може складатися з безлічі файлів), дозволяє перемикатися між файлами, пропонує автодоповнення за кодом всього проекту (а не тільки відкритого файлу), також вона інтегрована з системою контролю версій (наприклад, такий як <a href="https://git-scm.com/">git </a>), середовищем для тестування та іншими інструментами на рівні всього проекту. </p>
                    <p> Якщо ви ще не обрали собі IDE, придивіться до цих: </p>
                    <ul>
                        <li> <a href="https://code.visualstudio.com/"> Visual Studio Code </a> (безкоштовно). </li>
                        <li> <a href="http://www.jetbrains.com/webstorm/"> WebStorm </a> (платно). </li>
                    </ul>
                    <p> Обидві IDE - Кросплатформені. </p>
                    <p> Для Windows є ще Visual Studio (не плутати з Visual Studio Code). Visual Studio - це платна потужне середовище розробки, яка працює тільки на Windows. Вона добре підходить для .NET платформи. У неї є безкоштовна версія, яка називається <a href="https://www.visualstudio.com/vs/community/"> Visual Studio Community </a>. </p>
                    <p> Багато IDE платні, але у них є пробний період. Їх ціна зазвичай незначна в порівнянні з зарплатою кваліфікованого розробника, так що пробуйте і вибирайте ту, що вам підходить краще за інших. </p>
                    <h2> <a class="main__anchor" name="lyogkie-redaktory" href="#lyogkie-redaktory"> «Легкі» редактори </a> </h2> <p> «Легкі» редактори менш потужні, ніж IDE , але вони відрізняються швидкістю, зручним інтерфейсом і простотою. </p>
                    <p> В основному їх використовують для того, щоб швидко відкрити і відредагувати потрібний файл. </p>
                    <p> Головна відмінність між «легким» редактором і IDE полягає в тому, що IDE працює на рівні цілого проекту, тому вона завантажує більше даних при запуску, аналізує структуру проекту, якщо це необхідно, і так далі. Якщо ви працюєте тільки з одним файлом, то набагато швидше відкрити його в «легкому» редакторі. </p>
                    <p> На практиці «легкі» редактори можуть мати безліч плагінів, включаючи автодоповнення і аналізатори синтаксису на рівні директорії, тому кордону між IDE і «легкими» редакторами розмиті. </p>
                    <p> Наступні варіанти заслуговують вашої уваги: ​​</p>
                    <ul>
                        <li> <a href="https://atom.io/"> Atom </a> (багатоплатформовий, безкоштовний). </li>
                        <li> <a href="http://www.sublimetext.com"> Sublime Text </a> (багатоплатформовий, умовно-безкоштовний). </li>
                        <li> <a href="https://notepad-plus-plus.org/"> Notepad ++ </a> (Windows, безкоштовний). </li>
                        <li> <a href="http://www.vim.org/"> Vim </a> і <a href="https://www.gnu.org/software/emacs/"> Emacs </a> теж хороші, якщо знати, як ними користуватися. </li>
                    </ul>
                    <h2> <a class="main__anchor" name="ne-budem-ssoritsya" href="#ne-budem-ssoritsya"> Не будемо сваритися </a> </h2> <p> Редактори, перераховані вище, відомі автору давно і заслужили багато хороших відгуків від колег. </p>
                    <p> Звичайно ж, є багато інших відмінних редакторів. Вибирайте той, який вам більше подобається. </p>
                    <p> Вибір редактора, як і будь-якого іншого інструменту, індивідуальний і залежить від ваших проектів, звичок і особистих переваг. </p>
                </div>
                <h3 id='developersConsole'> Консоль розробника </h3>
                <div itemprop="articleBody">
                    <p> Код вразливий для помилок. І ви, швидше за все, будете робити помилки в коді ... Втім, давайте будемо відверті: ви <em> точно </em> будете робити помилки в коді. Зрештою, ви людина, а не <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D0%BD%D0%B4%D0%B5%D1%80_ (% D0% A4% D1% 83% D1% 82% D1% 83% D1% 80% D0% B0% D0% BC% D0% B0) "> робот </a>. </p>
                    <p> Але за замовчуванням у браузері помилки не видно. Тобто, якщо щось піде не так, ми не побачимо, що саме зламалося, і не зможемо це полагодити. </p>
                    <p> Для вирішення завдань такого роду в браузер вбудовані так звані «Інструменти розробки» (Developer tools або скорочено - devtools). </p>
                    <p> Chrome і Firefox здобули любов переважної більшості програмістів багато в чому завдяки своїм відмінним інструментів розробника. Решта браузери, хоча і оснащені подібними інструментами, але все ж найчастіше знаходяться в ролі наздоганяючих і за якістю, і за кількістю властивостей і особливостей. Загалом, майже у всіх програмістів є свій «улюблений» браузер. Інші використовуються тільки для вилову і виправлення специфічних «браузерозавісімих» помилок. </p>
                    <p> Для початку знайомства з цими потужними інструментами давайте з'ясуємо, як їх відкривати, дивитися помилки і запускати команди JavaScript. </p>
                    <h2> <a class="main__anchor" name="google-chrome" href="#google-chrome"> Google Chrome </a> </h2> <p> Відкрийте сторінку <a href="/ article / devtools /bug.html">bug.html </a>. </p>
                    <p> В її JavaScript-код закралася помилка. Вона не видно звичайному відвідувачу, тому давайте знайдемо її за допомогою інструментів розробки. </p>
                    <p> Натисніть <kbd class="shortcut"> F12 </kbd> або, якщо ви використовуєте Mac, <kbd class="shortcut"> Cmd <span class="shortcut__plus"> + </span> Opt <span class="shortcut__plus"> + </span> J </kbd>. </p>
                    <p> За замовчуванням в інструментах розробника відкриється вкладка Console (консоль). </p>
                    <p> Вона виглядає приблизно наступним чином: </p>
                    <figure>
                        <div class="image" style="width:707px">
                            <div class="image__ratio" style="padding-top:25px"></div>
                            <img src="https://learn.javascript.ru/article/devtools/chrome.png" alt="" width="707" height="240" class="image__image">
                        </div>
                    </figure><p>Точний зовнішній вигляд інструментів розробки залежить від використовуваної версії Chrome. Час від часу деякі деталі змінюються, але в цілому зовнішній вигляд залишається приблизно схожим на попередні версії.</p>
                    <ul>
                        <li> У консолі ми можемо побачити повідомлення про помилку, відмалює червоним кольором. У нашому випадку скрипт містить невідому команду «lalala». </li>
                        <li> Справа присутнє посилання на вихідний код <code> bug.html: 12 </code> з номером рядка коду, в якій ця помилка і сталася. </li>
                    </ul>
                    <p>Під повідомленням про помилку знаходиться синій символ <code>&gt;</code>.Він позначає командний рядок, в ній ми можемо редагувати і запускати JavaScript-команди. Для їх запуску натисніть <kbd class="shortcut">Enter</kbd>.</p>
                    <div class="important important_smart">
                        <div class="important__header"><span class="important__type">Складний введення</span></div>
                        <div class="important__content">
                            <p>Зазвичай при натисканні <kbd class="shortcut">Enter</kbd> введена рядок коду відразу виконується.</p>
                            <p>Щоб перенести рядок, натисніть <kbd class="shortcut">Shift<span class="shortcut__plus">+</span>Enter</kbd>. Так можна вводити більш довгий JS-код.</p>
                        </div>
                    </div>
                    <p>Тепер ми явно бачимо помилки, для початку цього цілком достатньо. Ми ще повернемося до інструментів розробника пізніше і більш докладно розглянемо налагодження коду в розділі <a href="/debugging-chrome">Отладка в браузері Chrome</a>.</p>
                    <h2><a class="main__anchor" name="firefox-edge-i-drugie" href="#firefox-edge-i-drugie">Firefox, Edge та інші</a></h2><p>Інструменти розробника в більшості браузерів відкриваються при натисканні на <kbd class="shortcut">F12</kbd>.</p>
                    <p>Їх зовнішній вигляд і принципи роботи мало чим відрізняються. Розібравшись з інструментами в одному браузері, ви без зусиль зможете працювати з ними і в іншому.</p>
                    <h2><a class="main__anchor" name="safari" href="#safari">Safari</a></h2><p>Safari (браузер для Mac, не підтримуються в системах Windows / Linux) все ж має невелику відмінність. Для початку роботи нам потрібно включити «Меню розробки» («Developer menu»).</p>
                    <p>Відкрийте Налаштування (Preferences) і перейдіть до панелі «Просунуті» (Advanced). У самому низу ви знайдете чекбокс:</p>
                    <figure>
                        <div class="image" style="width:774px">
                            <div class="image__ratio" style="padding-top:25px"></div>
                            <img src="https://learn.javascript.ru/article/devtools/safari.png" alt="" width="774" height="456" class="image__image">
                        </div>
                    </figure><p>Тепер консоль можна активувати натисканням клавіш<kbd class="shortcut">Cmd<span class="shortcut__plus">+</span>Opt<span class="shortcut__plus">+</span>C</kbd>. Також зверніть увагу на новий елемент меню «Розробка» («Develop»). У ньому міститься велика кількість команд і налаштувань.</p>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Разом</a></h2><ul>
                        <li>Інструменти розробника дозволяють нам дивитися помилки, виконувати команди, перевіряти значення змінних і ще багато всього корисного.</li>
                        <li>У більшості браузерів, що працюють під Windows, інструменти розробника можна відкрити, натиснувши <kbd class="shortcut">F12</kbd>. У Chrome для Mac використовуйте комбінацію <kbd class="shortcut">Cmd<span class="shortcut__plus">+</span>Opt<span class="shortcut__plus">+</span>J</kbd>, Safari: <kbd class="shortcut">Cmd<span class="shortcut__plus">+</span>Opt<span class="shortcut__plus">+</span>C</kbd> (необходимо предварительное включение «Меню разработчика»).</li>
                    </ul>
                    <p>Тепер наше оточення повністю настроєний. У наступному розділі ми перейдемо безпосередньо к JavaScript.</p>
                </div>
                <h3 id='helloWorld'>Привіт мир</h3>
                <div itemprop="articleBody">
                    <p>У цій частині підручника ми вивчаємо власне JavaScript, сама мова.</p>
                    <p>Але нам потрібна робоче середовище для запуску наших скриптів, і, оскільки це онлайн-книга, то браузер буде хорошим вибором. У цьому розділі ми скоротимо кількість специфічних для браузера команд (наприклад, <code> alert </code>) до мінімуму, щоб ви не витрачали на них час, якщо плануєте зосередитися на іншому середовищі (наприклад, Node.js). А на використанні JavaScript в браузері ми зосередимося в <a href="/ui"> наступній частині </a> підручника.</p>
                    <p>Отже, спочатку давайте подивимося, як виконати скрипт на сторінці. Для серверних середовищ (наприклад, Node.js), ви можете виконати скрипт за допомогою команди типу <code> "node my.js" </code>. Для браузера все трохи інакше.</p>
                    <h2><a class="main__anchor" name="teg-script" href="#teg-script">Тег «script»</a></h2><p>Програми на JavaScript можуть бути вставлені в будь-яке місце HTML-документа за допомогою тега <code>&lt;script&gt;</code>.</p>
                    <p>Для прикладу:</p>
                    <em><pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt; Перед скриптом...&lt;p&gt;
&lt;script&gt;
alert('Привіт, мир!')
&lt;script&gt;
&lt;p&gt;...Після скрипту.&lt;p&gt;
&lt;body&gt;
&lt;html&gt;</pre></em>
                            </div>
                        

                    <p>Ви можете запустити приклад, натиснувши на кнопку «Play» в правому верхньому кутку блоку з кодом вище.</p>
                    <p>Тег <code>&lt;script&gt;</code> містить JavaScript-код, який автоматично виконається, коли браузер його обробить.</p>
                    <h2><a class="main__anchor" name="sovremennaya-razmetka" href="#sovremennaya-razmetka">Сучасна розмітка</a></h2><p>Тег <code>&lt;script&gt;</code> має кілька атрибутів, які рідко використовуються, але все ще можуть зустрітися в старому коді:</p>
                    <dl>
                        <dt>Атрибут <code>type</code>: <code>&lt;script <u>type</u>=…&gt;</code></dt>
                        <dd>
                            <p>Старий стандарт HTML, HTML4, вимагав наявності цього атрибута в тезі<code>&lt;script&gt;</code>. Зазвичай він мав значення <code> type = "text / javascript" </code>. На поточний момент цього більше не потрібно. Більш того, в сучасному стандарті HTML сенс цього атрибута повністю змінився. Тепер він може використовуватися для JavaScript-модулів. Але це тема не для початкового рівня, і про неї ми поговоримо в іншій частині підручника.</p>
                        </dd>
                        <dt>Атрибут <code>language</code>: <code>&lt;script <u>language</u>=…&gt;</code></dt>
                        <dd>
                            <p>Цей атрибут повинен був ставити мову, на якому написаний скрипт. Але так як JavaScript є мовою за замовчуванням, в цьому атрибуті вже немає необхідності.</p>
                        </dd>
                        <dt>Обгортання скрипта в HTML-коментарі.</dt>
                        <dd>
                            <p>У дуже древніх книгах і посібниках ви зможете знайти коментарі всередині тега <code>&lt;script&gt;</code>, наприклад, такі:</p><pre>&lt;script type=text/javascript&gt;&lt;!--
...
//--&gt;script&gt;</pre>
                             <p>Цей коментар приховував код JavaScript в старих браузерах, які не знали, як обробляти тег <code>&lt;script&gt;</code>. Оскільки всі браузери, випущені за останні 15 років, не містять даної проблеми, такі коментарі вже не потрібні. Якщо вони є, то це ознака, що перед нами дуже древній код.</p>
                        </dd>
                    </dl>
                    <h2><a class="main__anchor" name="vneshnie-skripty" href="#vneshnie-skripty">Зовнішні скрипти </a></h2><p> Якщо у вас багато JavaScript-коду, ви можете помістити його в окремий файл. </p>
                    <p> Файл скрипта можна підключити до HTML за допомогою атрибута <code>src</code>:</p><pre>&lt;script src=/path/to/script.js"&gt;&lt;/script&gt;</pre>
                    <p>Тут <code>/path/to/script.js</code> - це абсолютний шлях до скрипта від кореня сайту. Також можна вказати відносний шлях від поточної сторінки. наприклад, <code>src="script.js"</code> буде означати, що файл <code>"script.js"</code> знаходиться в цій папці.</p>
                    <p>Можна вказати і повний URL-адресу. наприклад:</p>
                    <p>Для підключення декількох скриптів використовуйте кілька ключових слів:</p> <pre>&lt;script src="/js/script1.js"&gt;&lt;/script&gt;
&lt;script src="/js/script2.js"&gt;&lt;/script&gt;...</pre>
                        <div class="important important_smart">
                        <div class="important__header"><span class="important__type">На замітку:</span></div>
                        <div class="important__content">
                            <p>Як правило, тільки найпростіші скрипти поміщаються в HTML. Більш складні виділяються в окремі файли.</p>
                            <p> Користь від окремих файлів в тому, що браузер завантажить скрипт окремо і зможе зберігати його в <a href="https://en.wikipedia.org/wiki/Web_cache">кеше</a>.</p>
                            <p>Інші сторінки, які підключають той же скрипт, зможуть брати його з кеша замість повторного завантаження з мережі. І таким чином файл буде завантажуватися з сервера тільки один раз.</p>
                            <p>Це скорочує витрату трафіку і пришвидшує роботу.</p>
                        </div>
                    </div>
                    <div class="important important_warn">
                        <div class="important__header"><span class="important__type">Якщо атрибут <code>src</code> встановлено, вміст тега <code> script </code> буде ігноруватися.</span></div>
                            <p>В одному тезі<code>&lt;script&gt;</code> не можна використовувати одночасно атрибут <code>src</code> і код всередині.</p>
                            <p>Нижченаведений приклад не працює:</p><pre>&lt;script src="file.js"&gt;
alert(1); // вміст ігнорується, так як є атрибут src
&lt;/script&gt;</pre>
                            <p>Потрібно вибрати: або зовнішній скрипт <code>&lt;script src="…"&gt;</code>, або звичайний код всередині тега <code>&lt;script&gt;</code>.</p>
                            <p>Вищенаведений приклад можна розділити на два скрипта:</p><pre>&lt;script src="/span>file.js"&gt;&lt;script&gt;>
&lt;script&gt;
alert(1);
&lt;/script&gt;</pre>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Итого</a></h2><ul>
                        <li>Для додавання коду JavaScript на сторінку використовується тег <code>&lt;script&gt;</code></li>
                        <li>Атрибути <code>type</code> и <code>language</code> необов'язкові.</li>
                        <li>Скрипт в зовнішньому файлі можна вставити за допомогою <code>&lt;script src="path/to/script.js"&gt;&lt;/script&gt;</code>.</li>
                    </ul>
                    <p>Нам ще багато що належить вивчити про браузерні скрипти і їх взаємодія зі сторінкою. Але, як уже було сказано, ця частина підручника присвячена саме мови JavaScript, тому тут ми постараємося не відволікатися на деталі реалізації в браузері. Ми скористаємося браузером для запуску JavaScript, це зручно для онлайн-демонстрацій, але це тільки одна з платформ, на яких працює ця мова.</p>
                </div>
                <h3 id='codeStructure'>Структура коду</h3>
                <div itemprop="articleBody">
                    <p>Почнемо вивчення мови з розгляду основних «будівельних блоків» коду.</p>
                    <h2><a class="main__anchor" name="instruktsii" href="#instruktsii">Інструкції</a></h2><p>Інструкції - це синтаксичні конструкції і команди, які виконують дії.</p>
                    <p> Ми вже бачили інструкцію <code> alert ('Привіт, світ!') </code>, яка відображає повідомлення «Привіт, світ!». </p>
                    <p> В нашому коді може бути стільки інструкцій, скільки ми захочемо. Інструкції можуть відділятися крапкою з комою. </p>
                    <p> Наприклад, тут ми розділили повідомлення «Привіт Світ» на два виклики alert: </p><pre>alert('Привіт'); alert('Мир');</pre>
                    <p>Зазвичай кожну інструкцію пишуть на новому рядку, щоб код було легше читати:</p><pre>alert('Привет');
alert('Мир');</pre>
                    <h2><a class="main__anchor" name="semicolon" href="#semicolon">Крапка з комою </a></h2><p> В більшості випадків крапку з комою можна не ставити, якщо є перехід на новий рядок.</p>
                    <p>Так тоже будет работать:</p><pre>alert('Привет')
alert('Мир')</pre>
                    <p>В цьому випадку JavaScript інтерпретує перенесення рядка як «неявну» крапку з комою. Це називається <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion"> автоматична вставка крапки з комою </a>. </p>
                    <p> <strong> У більшості випадків новий рядок має на увазі крапку з комою. Але «в більшості випадків» не означає «завжди»! </strong> </p>
                    <p> В деяких ситуаціях новий рядок все ж не означає крапку з комою. наприклад:</p><pre>alert(3+1+2);</pre>
                    <p> Код виведе <code> 6 </code>, тому що JavaScript не вставляти тут крапку з комою. Інтуїтивно очевидно, що, якщо рядок закінчується знаком <code> "+" </code>, значить, це «незавершене вираз», тому крапка з комою не потрібно. І в цьому випадку все працює, як задумано. </p>
                    <p> <strong> Але є ситуації, де JavaScript «забуває» вставити крапку з комою там, де вона потрібна. </strong> </p>
                    <p> Помилки, які при цьому виникають, досить складно виявляти і виправляти. </p>
                    <div class="important__header"><span class="important__type">Приклад помилки</span></div>
                    <p>Якщо ви хочете побачити конкретний приклад такої помилки, зверніть увагу на цей код:</p><pre>[1, 2]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span></code></pre>
                    <p>Поки немає необхідності знати значення дужок <code> [] </code> і <code> forEach </code>. Ми вивчимо їх пізніше. Поки що просто запам'ятайте результат виконання цього коду: виводиться <code> 1 </code>, а потім <code> 2 </code>. </p>
                    <p> А тепер додамо <code> alert </code> перед кодом і <em> не </em> поставимо в кінці крапку з комою:</p><pre>alert("Сейчас будет ошибка")
[1, 2].forEach(alert)</pre>
                    <p>Тепер, якщо запустити код, виведеться тільки перший <code> alert </code>, а потім ми отримаємо помилку! </p>
                    <p> Все виправиться, якщо ми поставимо крапку з комою після <code>alert</code>:</p><pre>alert("Теперь всё в порядке");
[1,2].forEach(alert)</pre>
                    <p>Тепер ми отримаємо повідомлення «Тепер все в порядку», слідом за яким будуть <code> 1 </code> і <code> 2 </code>. </p>
                    <p>В першому прикладі без крапки з комою виникає помилка, тому що JavaScript не вставляти крапку з комою перед квадратними дужками <code> [...] </code>. І тому код в першому прикладі виконується, як одна інструкція. Ось як движок бачить його:</p>
                    <pre>alert("Сейчас будет ошибка")[1, 2].forEach(alert)</pre>
                    <p>Але це повинні бути дві окремі інструкції, а не одна. Таке злиття в даному випадку неправильне, тому й помилка. Це може статися і в деяких інших ситуаціях. </p>
                    <p> Ми рекомендуємо ставити крапку з комою між інструкціями, навіть якщо вони відокремлені переносами рядків. Це правило широко використовується в співтоваристві розробників. Варто відзначити ще раз - в більшості випадків <em> можна </em> не ставити крапку з комою. Але безпечніше, особливо для новачка, ставити її. </p>
                    <h2><a class="main__anchor" name="kommentarii" href="#kommentarii"> Коментарі </a></h2><p> З часом програми стають все складніше і складніше. Виникає необхідність додавати <em> коментарі </em>, які б описували, що робить код і чому. </p>
                    <p> Коментарі можуть перебувати в будь-якому місці скрипта. Вони не впливають на його виконання, оскільки движок просто ігнорує їх. </p>
                    <p> <strong> Однорядкові коментарі починаються з подвійною косою риси <code> // </code>. </strong> </p>
                    <p> Частина рядка після <code> // </code> вважається коментарем. Такий коментар може як займати рядок цілком, так і перебувати після інструкції. </p>
                    <p> Як тут:</p><pre>// Этот комментарий занимает всю строку
alert('Привет');
alert('Мир'); // Этот комментарий следует за инструкцией</pre>
                    <p><strong>Багаторядкові коментарі починаються косою рисою із зірочкою <code> / * </code> і закінчуються зірочкою з косою рисою <code>*/</code>.</strong></p>
                    <p>Как вот здесь:</p><pre>/* Приклад з двома повідомленнями.
Це - багаторядковий коментар.*/
alert('Привіт');
alert('Мир');</pre>
                    <p>Вміст коментаря ігнорується, тому, якщо ми помістимо код всередині <code> / * ... * / </code>, він не буде виконуватися. </p>
                    <p> Це буває зручно для тимчасового відключення ділянки коду:</p><pre>/* Закомментировали код
alert('Привет');
*/
alert('Мир');</pre>
             <div class="important important_smart">
             <div class="important__header"><span class="important__type">Використовуйте гарячі клавіші!</span></div>
             <div class="important__content">
             <p>У більшості редакторів рядок коду можна закомментировать, натиснувши комбінацію клавіш <kbd class="shortcut">Ctrl<span class="shortcut__plus">+</span>/</kbd> для однострочного коментаря і щось на зразок <kbd class="shortcut">Ctrl<span class="shortcut__plus">+</span>Shift<span class="shortcut__plus">+</span>/</kbd> – для многострочных комментариев (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте <kbd class="shortcut">Cmd</kbd> вместо <kbd class="shortcut">Ctrl</kbd> и <kbd class="shortcut">Option</kbd> вместо <kbd class="shortcut">Shift</kbd>.</p>
             </div>
             </div>
                    <div class="important__header"><span class="important__type"> Вкладені коментарі не підтримуються!</span></div>
                            <p>Не может быть <code>/*...*/</code> внутри <code>/*...*/</code>.</p>
                            <p>Такой код «умрёт» с ошибкой:</p><pre>/*
 /* вложенный комментарий ?!? */
*/
alert('Мир');</pre>
                    <p>Не соромтеся використовувати коментарі в своєму коді. </p>
                    <p> Коментарі збільшують розмір коду, але це не проблема. Є безліч інструментів, які мініфіціруют код перед публікацією на робочий сервер. Вони прибирають коментарі, так що вони не містяться в робочих скриптах. Таким чином, коментарі жодним чином не шкодять робочому коду. </p>
                    <p> Пізніше в підручнику буде глава <a href="/code-quality"> Якість коду </a>, яка пояснить, як краще писати коментарі. </p>
                </div>
                <h3 id='useStrict'> Суворий режим use strict</h3>
                <div itemprop="articleBody">
                    <p> Протягом довгого часу JavaScript розвивався без проблем з зворотною сумісністю. Нові функції додавалися в мову, в той час як стара функціональність не змінювалася. </p>
                    <p> Перевагою даного підходу було те, що існуючий код продовжував працювати. А недоліком - що будь-яка помилка або недосконале рішення, прийняте творцями JavaScript, застрявали в мові назавжди. </p>
                    <p> Так було до 2009 року, коли з'явився ECMAScript 5 (ES5). Він додав нові можливості в мову і змінив деякі з існуючих. Щоб застарілий код працював, як і раніше, за замовчуванням подібні зміни не застосовуються. Тому нам потрібно явно їх активувати за допомогою спеціальної директиви: <code> "use strict" </code>. </p>
                    <h2> <a class="main__anchor" name="use-strict" href="#use-strict"> «use strict» </a></h2><p> Директива виглядає як рядок: <code> " use strict "</code> або <code> 'use strict' </code>. Коли вона знаходиться на початку скрипта, весь сценарій працює в «сучасному» режимі.</p>
                    <p>Напиклад:</p>
                       <pre> "use strict";
// цей код працює в сучасному режимі
...</pre>
                    <p>Пізніше ми вивчимо функції (спосіб угруповання команд). Забігаючи вперед, зауважимо, що замість усього скрипта <code> "use strict" </code> можна поставити на початку більшості видів функцій. Це дозволяє включити строгий режим тільки в конкретній функції. Але зазвичай люди використовують його для всього файлу.</p>
                     <div class="important__header"><span class="important__type">Переконайтеся, що «use strict» знаходиться на початку</span></div>
                            <p>Проверьте, что <code>"use strict"</code> знаходиться в першій виконуваної рядку скрипта, інакше строгий режим може не включитися.</p>
                            <p>Тут суворий режим не включений:</p><pre>alert("some code");
// "use strict" нижче ігнорується - він повинен бути в першому рядку
"use strict";
// строгий режим не активований</pre>
                                    <p>Над <code>"use strict"</code> можуть бути записані тільки коментарі.</p>
                        
                    <div class="important important_warn">
                        <div class="important__header"><span class="important__type">Немає ніякого способу скасувати <code> use strict </code> </span> </div>
                        <div class="important__content">
                            <p>Ні директиви типу <code> "no use strict" </code>, яка повертала б движок до старої поведінки.</p>
                            <p>Як тільки ми входимо в строгий режим, скасувати це неможливо.</p>
                        </div>
                    </div>
                    <h2><a class="main__anchor" name="konsol-brauzera" href="#konsol-brauzera">Консоль браузера</a></h2><p>Надалі, коли ви будете використовувати <a href="/devtools">консоль браузера</a> для тестування функцій, зверніть увагу, що <code>use strict</code> за замовчуванням в ній вимкнений.</p>
                    <p>Іноді, коли <code> use strict </code> має значення, ви можете отримати неправильні результати.</p>
                    <p>Можно использовать <kbd class="shortcut">Shift<span class="shortcut__plus">+</span>Enter</kbd> для введення декількох рядків і написати у верхньому рядку <code>use strict</code>:</p><pre>'use strict'; &lt;Shift+Enter для перехода на новую строку&gt;
//  ...ваш код...
&lt;Enter для запуска&gt;</pre>
                    <p>У більшості браузерів, включаючи Chrome і Firefox, це працює. </p>
                    <p> В старих браузерах консоль не враховує такий <code> use strict </code>, там можна «обертати» код в функцію, ось так:</p><pre>(function(){
'use strict';
// ...ваш код...
})</pre>
    <h2><a class="main__anchor" name="vsegda-li-nuzhno-ispolzovat-use-strict" href="#vsegda-li-nuzhno-ispolzovat-use-strict">Чи завжди потрібно використовувати «use strict»? </a> </h2> <p> Питання здається риторичним, але це не так. </p>
                    <p> Хтось порадить починати кожен скрипт з <code> "use strict" </code> ... Але є спосіб покруче. </p>
                    <p> Сучасний JavaScript підтримує «класи» і «модулі» - просунуті структури мови (і ми, звичайно, до них доберемося), які автоматично включають строгий режим. Тому в них немає потреби додавати директиву <code> "use strict" </code>. </p>
                    <p> <strong>Підсумуємо: поки дуже бажано додавати <code> "use strict"; </code> на початку ваших скриптів. Пізніше, коли весь ваш код буде складатися з класів і модулів, директиву можна буде опускати. </strong> </p>
                    <p>Поки ми дізналися про <code> use strict </code> тільки в загальних рисах. </p>
                    <p>В наступних розділах, у міру розширення знань про можливості мови, ми ясніше побачимо відмінності між строгим і стандартним режимом. На щастя, їх не так багато, і всі вони роблять життя розробника краще. </p>
                    <p>Всі приклади в цьому підручнику мають на увазі виконання в строгому режимі, за винятком випадків (дуже рідкісних), коли обумовлено інше.</p>
                </div>
                <h3 id='variables'>Змінні</h3>
                <div itemprop="articleBody">
                    <p>JavaScript-додатком зазвичай потрібно працювати з інформацією. наприклад:</p>
                    <ol>
                        <li>Інтернет-магазин - інформація може включати товари й кошик. </li>
                        <li> Чат - інформація може включати користувачів, повідомлення та багато іншого.</li>
                    </ol>
                    <p>Змінні використовуються для зберігання цієї інформації.</p>
                    <h2><a class="main__anchor" name="peremennaya" href="#peremennaya">Змінна</a></h2><p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">Змінна</a> – це іменоване сховище» для даних. Ми можемо використовувати змінні для зберігання товарів, відвідувачів і інших даних.</p>
                    <p>Для створення змінної в JavaScript використовуйте ключове слово <code>let</code>.</p>
                    <p>Наведена нижче інструкція створює (іншими словами: <em> оголошує </em> або <em> визначає </em>) змінну з ім'ям «message»:</p><pre>let message;</pre>
                    <p>Тепер можна помістити в неї дані, використовуючи оператор присвоювання <code>=</code>:</p> <pre>let message;
<em>message= 'Hello'; // сохранить строку</em></pre>
                    <p>Рядок зберігається в області пам'яті, пов'язаної зі змінною. Ми можемо отримати до неї доступ, використовуючи ім'я змінної:</p><pre>let message;
message= 'Hello!';
<em>alert(message); // показывает содержимое переменной</em></pre>
                    <p>Для краткости можно совместить объявление переменной и запись данных в одну строку:</p><pre>let message= 'Hello!'; // определяем переменную и присваиваем ей значение
alert(message); // Hello!</pre>
                    <p>Ми також можемо оголосити кілька змінних в одному рядку:</p><pre>let user = 'John', age = 25, message = 'Hello';</pre>
                    <p>Такий спосіб може здатися коротше, але ми не рекомендуємо його.Для кращої читання оголошуйте кожну змінну на новому рядку.</p>
                    <p> Багаторядковий варіант трохи довше, але легше для читання:</p><pre> user = 'John';
let age = 25;
let message = 'Hello';</pre>
                    <p>Деякі люди також визначають кілька змінних в такому ось багаторядковому стилі:</p><pre>let user = 'John',
age = 25,
message = 'Hello';</pre>
                    <p>... Або навіть з коми на початку рядка:</p><pre>let user = 'John', age = 25, message = 'Hello';</pre>
                    <p>В принципі, всі ці варіанти працюють однаково. Так що це питання особистого смаку та естетики.</p>
                    <div class="important important_smart">
                        <div class="important__header"><span class="important__type"><code>var</code> замість <code>let</code></span></div>
                            <p>У старих скриптах ви також можете знайти інші пов'язані дані: <code>var</code> замість <code>let</code>:</p><pre><em>var</em> message = 'Hello';</pre>
                            <p>Ключове слово <code> var </code> - <em> майже </em> те ж саме, що і <code> let </code>. Воно оголошує змінну, але трохи по-іншому, «застарілим» способом. </p>
                            <p>Є тонкі відмінності між <code> let </code> і <code> var </code>, але вони поки не мають для нас значення. Ми детально розглянемо їх в розділі <a href="/var"> Застаріле ключове слово "var"</a>.</p>
                        </div>
                    <h2><a class="main__anchor" name="analogiya-iz-zhizni" href="#analogiya-iz-zhizni">Аналогія з життя </a></h2><p> Ми легко зрозуміємо концепцію «змінної», якщо уявимо її у вигляді «коробки» для даних з унікальною назвою на ній. </p>
                    <p>Наприклад, змінну <code> message </code> можна уявити як коробку з назвою <code>"message"</code> и значением <code>"Hello!"</code> внутри:</p>
                   <!-- <figure><div class="image" style="width:166px">
      <div class="image__ratio" style="padding-top:87.34939759036145%"></div>
      <object type="image/svg+xml" data="/article/variables/variable.svg" width="166" height="145" class="image__image">
        <img src="/article/variables/variable.svg" alt="" width="166" height="145">
      </object>
      </div></figure>-->
                    <p>Ми можемо покласти будь-яке значення в коробку. </p>
                    <p>Ми також можемо змінити його стільки разів, скільки захочемо:</p><pre>let message;
message = 'Hello!';
message = 'World!'; // значение изменено
alert(message);</pre>
                    <p>При зміні значення старі дані видаляються з змінної: </p>
                    <p>Ми також можемо оголосити дві змінні і скопіювати дані з однієї в іншу.</p><pre>let hello = 'Hello world!';
let message;
<em>// копіюємо значення 'Hello world' з змінної hello в змінну message
message = hello;</em>
// тепер дві змінні містять однакові дані
alert(hello); // Hello world!>
alert(message); // Hello world!</pre>
                        <div class="important important_warn">
                        <div class="important__header"><span class="important__type">Повторне оголошення викликає помилку </span></div>
                        <div class="important__content">
                            <p> Змінна може бути оголошена тільки один раз.</p>
                            <p><b>Повторне оголошення тієї ж змінної є помилкою:</b></p><pre>let message = "Это";
повторення ключового слова 'let' призводить до помилки
let message = "Друге"; // SyntaxError: 'message' has already been declared</pre>
                            <p>Тому слід оголошувати змінну тільки один раз і потім використовувати її вже без <code>let</code>.</p>
                        </div>
                        <div class="important important_smart">
                        <div class="important__header"><b>Функціональні мови програмування </b></div>
                        <div class="important__content">
                            <p>Примітно, що існують <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">функциональные</a> языки программирования, такие как <a href="http://www.scala-lang.org/">Scala</a> или <a href="http://www.erlang.org/">Erlang</a>, которые запрещают изменять значение переменной.</p>
                            <p>У таких мовах одного разу збережене «в коробку» значення залишається там назавжди. Якщо нам потрібно зберегти щось інше, мова змушує нас створити нову коробку (оголосити нову змінну). Ми не можемо використовувати стару змінну. </p>
                            <p>Хоча на перший погляд це може здатися трохи дивним, ці мови цілком підходять для серйозної розробки.Більш того, є така область, як паралельні обчислення, де це обмеження дає певні переваги. Вивчення такого мови (навіть якщо ви не плануєте використовувати його в найближчим часом) рекомендується для розширення кругозору.
                            </p>
                        </div>
                    </div>
                    <h2><a class="main__anchor" name="variable-naming" href="#variable-naming">Імена змінних</a></h2><p>В JavaScript є два обмеження, що стосуються імен змінних:</p>
                    <ol>
                        <li>Ім'я змінної має містити тільки букви, цифри або символи <code> $ </code> і <code> _ </code>. </li>
                        <li> Перший символ не повинен бути цифрою.</li>
                    </ol>
                    <p>Приклади допустимих імен:</p><pre>let userName;
let test123;</pre>
                    <p>Якщо ім'я містить кілька слів, зазвичай використовується <a href="https://ru.wikipedia.org/wiki/CamelCase"> верблюжа нотація </a>,
                       тобто, слова слідують одне за іншим, де кожне наступне слово починається з великої літери: <code> myVeryLongName </code>.
                    </p>
                    <p> Найцікавіше - знак долара <code> '$' </code> і підкреслення <code> '_' </code> також можна використовувати в назвах. Це звичайні символи, як і букви, без будь-якого особливого значення. </p>
                    <p> Ці імена є допустимими:</p>
                    <pre>let $ =1; // объявили переменную с именем "$"
let _ = 2; // а тепер змінну з ім'ям"_"
alert($ + _); // 3</pre>
                     <p>Приклади неправильних імен змінних:</p><pre>let 1a; // не может начинаться с цифры
let my-name; // дефис '-' НЕ дозволений в імені</pre>
                        <div class="important__header"><span class="important__type"><b>Регістр має значення</b></span></div>
                        <p> Змінні з іменами <code> apple </code> і <code> AppLE </code> - це дві різні змінні.</p>
                        </div>
                        <div class="important__header"><span class="important__type"><b>Нелатинські букви дозволені, але не рекомендуються</b></span></div>
                        <p> Можна використовувати будь-яку мову, включаючи кирилицю або навіть ієрогліфи, наприклад:</p><pre>let имя = '...';
let 我 = '...';</pre>
                        <p>Технічно тут немає помилки, такі імена дозволені, але є міжнародна традиція використовувати англійську мову в іменах змінних. Навіть якщо ми пишемо невеликий скрипт, у нього може бути довге життя попереду. Людям з інших країн, можливо, доведеться прочитати його не один раз.</p>
                         <div class="important__header"><span class="important__type"><b>Зарезервовані імена</b></span></div>
                            <p>Существует <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0">список зарезервированных слов</a>, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.</p>
                            <p>Наприклад: <code>let</code>, <code>class</code>, <code>return</code> и <code>function</code> зарезервовані.</p>
                            <p> Наведений нижче код дає синтаксичну помилку:</p><pre>let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!</span></code></pre>
                         
                    <div class="important important_warn">
                       <div class="important__header"><span class="important__type"><b>Створення змінної без використання <code>use strict</b></code></span></div>
                          <p>Зазвичай нам потрібно визначити змінну перед її використанням. Але в старі часи було технічно можливо створити змінну простим привласненням значення без використання <code> let </code>. Це все ще працює, якщо ми не включаємо <code> use strict </code> в наших файлах, щоб забезпечити сумісність зі старими скриптами.</p>
                          <pre>// заметка: "use strict" в этом примере не используется
num = 5; // если переменная "num" раньше не существовала, она создаётся
alert(num); // 5</pre>
                          <p>Це погана практика, яка призводить до помилки в строгому режимі:</p><pre>"use strict";
<em class="block-highlight">num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// ошибка: num is not defined</span></em></code></pre>
                     </div>                                        
                    <h2><a class="main__anchor" name="pridumyvayte-pravilnye-imena" href="#pridumyvayte-pravilnye-imena">Придумуйте правильні імена </a></h2><p> В розмові про змінних необхідно згадати, що є ще одна надзвичайно важлива річ. </p>
                    <p> Назва змінної повинно мати ясний і зрозумілий сенс, говорити про те, які дані в ній зберігаються. </p>
                    <p> Іменування змінних - це один з найбільш важливих і складних навичок в програмуванні. Швидкий погляд на імена змінних може показати, який код був написаний новачком, а який - досвідченим розробником. </p>
                    <p> В реальному проекті велика частина часу витрачається на зміну і розширення існуючої кодової бази, а не на написання чогось абсолютно нового з нуля. Коли ми повертаємося до коду після якогось проміжку часу, набагато легше знайти інформацію, яка добре розмічена. Або, іншими словами, коли змінні мають хороші імена. </p>
                    <p> Будь ласка, витратьте час на обдумування правильного імені змінної перед її оголошенням. Робіть так, і будете винагороджені. </p>
                    <p> Кілька хороших правил:</p>
                    <ul>
                        <li>Використовуйте легко читаються імена, такі як <code> userName </code> або <code> shoppingCart </code>. </li>
                        <li> Уникайте використання абревіатур або коротких імен, таких як <code> a </code>, <code> b </code>, <code> c </code>, за винятком тих випадків, коли ви точно знаєте, що так потрібно. </li>
                        <li> Робіть імена максимально описовими і лаконічними. Приклади поганих імен: <code>data</code> и <code>value</code>. Такі імена нічого не говорять. Їх можна використовувати тільки в тому випадку, якщо з контексту коду очевидно, якісь дані зберігає змінна.</li>
                        <li> Домовтеся з вашою командою про використовуваних термінах. Якщо відвідувач сайту називається «user», тоді ми повинні називати пов'язані з ним змінні <code>currentUser</code> или <code>newUser</code>, а не, к примеру, <code>currentVisitor</code> или <code>newManInTown</code>. </li>
                    </ul>
                    <p>Звучить просто? Дійсно, це так, але на практиці для створення описових і коротких імен змінних найчастіше потрібна подумати. Дійте.</p>
                    <div class="important important_smart">
                        <div class="important__header"><span class="important__type">Повторно використовувати або створювати нову змінну? </span> </div>
                        <div class="important__content">
                            <p> І остання замітка. Є ледачі програмісти, які замість оголошення нових змінних повторно використовують існуючі. </p>
                            <p> В результаті їх змінні схожі на коробки, в які люди кидають різні предмети, не змінюючи на них етикетки. Що зараз знаходиться всередині коробки? Хто знає? Нам необхідно підійти ближче і перевірити. </p>
                            <p> Такі програмісти трохи економлять на оголошенні змінних, але втрачають в десять разів більше при налагодженні. </p>
                            <p> Додаткова змінна - це добро, а не зло. </p>
                            <p> Сучасні JavaScript-мініфікатори і браузери оптимізують код досить добре, тому він не створює проблем з продуктивністю. Використання різних змінних для різних значень може навіть допомогти движку оптимізувати ваш код.</p>
                        </div>
                    </div>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Итого</a></h2><p>Ми можемо оголосити змінні для зберігання даних за допомогою ключових слів <code>var</code>, <code>let</code> или <code>const</code>.</p>
                    <ul>
                        <li><code>let</code> – це сучасний спосіб оголошення. </li>
                        <li> <code> var </code> - це застарілий спосіб оголошення. Зазвичай ми взагалі не використовуємо його, але ми розглянемо тонкі відмінності від <code> let </code> в розділі <a href="/var"> Застаріле ключове слово "var" </a> на випадок, якщо це все-таки вам знадобиться. </li>
                        <li> <code> const </code> - схоже на <code> let </code>, але значення змінної не може змінюватися.</li>
                    </ul>
                    <p>Змінні повинні бути названі таким чином, щоб ми могли легко зрозуміти, що у них всередині.</p>
                </div>
                <h3 id='dataTypes'>Типи даних</h3>
                    <p>Значення в JavaScript завжди відноситься до даних певного типу. Наприклад, це може бути рядок або число. </p>
                    <p> Є вісім основних типів даних в JavaScript. У цьому розділі ми розглянемо їх в загальному, а в наступних розділах поговоримо докладніше про кожен. </p>
                    <p> Змінна в JavaScript може містити будь-які дані. В один момент там може бути рядок, а в іншій - число:</p>
                    <pre>// Не будет ошибкой
let message = "hello";
message = 123456;</pre>
                    <p>Мови програмування, в яких таке можливо, називаються «динамічно типізований». Це означає, що типи даних є, але змінні не прив'язані до жодного з них.</p>
                    <h2><a class="main__anchor" name="chislo" href="#chislo">Число</a></h2>
                    <pre>let n  ;
n= 12.345;</pre>
                           <p><em>Числовий </em> тип даних (<code> number </code>) представляє як цілочисельні значення, так і числа з плаваючою крапкою. </p>
                    <p> Існує безліч операцій для чисел, наприклад, множення <code> * </code>, розподіл <code> / </code>, складання <code> + </code>, віднімання <code> - </code> і так далі. </p>
                    <p> Крім звичайних чисел, існують так звані «спеціальні числові значення», які відносяться до цього типу даних: <code>Infinity</code>, <code>-Infinity</code> и <code>NaN</code>.</p>
                    <ul>
                        <li>
                            <p><code>Infinity</code> є математичною <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%81%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C#%D0%92_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B5">бесконечность</a> ∞. Это особое значение, которое больше любого числа.</p>
                            <p>Ми можемо отримати його в результаті поділу на нуль:</p>
                            <pre>alert( 1 / 0 ); // Infinity</pre>
                            <p>Или задать его явно:</p>
                            <pre>alert(Infinity ); // Infinity</pre>
                        </li>
                        <li>
                            <p><code>NaN</code> означає обчислювальну помилку. Це результат неправильної або невизначеної математичної операції, наприклад:</p>
                            <pre>alert( "не число" / 2 ); // NaN, такое деление является ошибкой</pre>
                            <p>Значение <code>NaN</code> «прилипчиво».  Люба операція с <code>NaN</code>повертає <code>NaN</code>:</p>
                            <pre>alert( "не число" / 2 + 5 ); // NaN</pre>
                            <p>Еякщо десь в математичному вираженні є <code> NaN </code>, то результатом обчислень з його участю буде <code>NaN</code>.</p>
                        </li>
                    </ul>
                    <p>Спеціальні числові значення відносяться до типу «число». Звичайно, це не числа в звичному значенні цього слова. </p>
                    <p> Детальніше про роботу з числами ми поговоримо в розділі <a href="/number">Числа</a>.</p>
                    <h2><a class="main__anchor" name="bigint" href="#bigint">BigInt</a></h2><p>В JavaScript тип «number» не може містити числа більше, ніж <code> (2 <sup> 53 </sup> -1) </code> (т. Е. <Code> 9007199254740991 </Code>), або менше , ніж <code> - (2 <sup> 53 </sup> -1) </code> для негативних чисел. Це технічне обмеження викликано їх внутрішнім поданням. </p>
                    <p> Для більшості випадків цього достатньо. Але іноді нам потрібні дійсно гігантські числа, наприклад, в криптографії або при використанні мітки часу ( «timestamp») з мікросекундами. </p>
                    <p> Тип <code> BigInt </code> був доданий в JavaScript, щоб дати можливість працювати з цілими числами довільної довжини. </p>
                    <p> Щоб створити значення типу <code> BigInt </code>, необхідно додати <code> n </code> в кінець числового литерала:</p><pre>// символ "n" в кінці означає, що це BigInt
const bigInt = 1234567890123456789012345678901234567890n;</pre>
                    <p>Так как <code>BigInt</code>-числа потрібні досить рідко, ми розглянемо їх в окремому розділі <a href="/bigint"> BigInt </a>. Ознайомтеся з нею, коли вам знадобляться настільки великі числа.</p>
                    <h2><a class="main__anchor" name="stroka" href="#stroka">Строка</a></h2><p>Строка (<code>string</code>) в JavaScript повинна бути укладена в лапки.</p><pre>let str = "Привет";
let str2 = 'Одинарні лапки теж підійдуть';
let phrase = `Зворотні лапки дозволяють вбудовувати змінні ${str}`;</pre>
                    <p>В JavaScript існує три типи лапок.</p>
                    <ol>
                        <li>Двойні кавички: <code>"Привіт"</code>.</li>
                        <li>Одинарні кавички: <code>'Привіт'</code>.</li>
                        <li>Обратні кавички: <code>`Привіт`</code>.</li>
                    </ol>
                    <p>Подвійні або одинарні лапки є «простими», між ними немає різниці в JavaScript. </p>
                    <p> Зворотні ж лапки мають розширену функціональність. Вони дозволяють нам вбудовувати вираження в рядок, укладаючи їх в <code>${…}</code>. Наприклад:</p>
                    <pre>let name ="Иван";
// Вставим переменную
alert( `Привіт, <em>${name}</em>!` ); // Привет, Иван!
// Вставим выражение
alert( `результат: <em>${1 + 2}</em>`); // результат: 3</pre>
                    <p>Вираз всередині <code> $ {...} </code> обчислюється, і його результат стає частиною рядка. Ми можемо покласти туди все, що завгодно: змінну <code> name </code>, або вираз <code> 1 + 2 </code>, або щось більш складне. </p>
                    <p> Зверніть увагу, що це можна робити тільки в зворотних лапках. Інші лапки не мають такої функціональності вбудовування!</p>
                   <pre>alert( "результат: ${1 + 2}" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)</pre>
                   <p>Ми розглянемо рядки більш докладно в розділі <a href="/string">Строки</a>.</p>
                    <div class="important important_smart">
                        <div class="important__header"><span class="important__type">Немає окремого типу даних для одного символу. </span> </div>
                        <div class="important__content">
                            <p> В деяких мовах, наприклад C і Java, для зберігання одного символу, наприклад <code> "a" </code> або <code> "%" </code>, існує окремий тип. У мовах C і Java це <code> char </code>. </p>
                            <p> В JavaScript подібного типу немає, є тільки тип <code> string </code>. Рядок може містити нуль символів (бути порожній), один символ або безліч.</p>
                        </div>
                    </div>
                    <h2><a class="main__anchor" name="bulevyy-logicheskiy-tip" href="#bulevyy-logicheskiy-tip">Булевий (логічний) тип </a> </h2> <p> булевий тип (<code> boolean </code>) може приймати тільки два значення: <code> true </code> (істина) і <code> false </code> (брехня). </p>
                    <p> Такий тип, як правило, використовується для зберігання значень так / ні: <code> true </code> означає «так, правильно», а <code>false</code> значит «нет, не правильно».</p>
                    <p>Наприклад:</p>
                    <pre>let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено</pre>
                     <p>Булеві значення також можуть бути результатом порівнянь:</p>
                     <pre>let isGreater = 4 &gt; 1;
alert(isGreater);// true (результатом сравнения будет "да")</pre>
                    <p>Ми розглянемо булеві значення більш докладно в розділі <a href="/logical-operators"> Логічні оператори</a>.</p>
                    <h2><a class="main__anchor" name="znachenie-null" href="#znachenie-null">Значення «null»</a></h2><p>Спеціальне значення <code>null</code> не відноситься ні до одного з типів, описаних вище.</p>
                    <p>Воно формує окремий тип, який містить тільки значення <code>null</code>:</p>
                    <pre>let age = null;</pre>
                    <p>В JavaScript <code>null</code> не є «посиланням на неіснуючий об'єкт» або «нульовим покажчиком», як в деяких інших мовах. </p>
                    <p> Це просто спеціальне значення, яке представляє собою «нічого», «порожньо» або «значення невідомо». </p>
                    <p> У наведеному вище коді вказано, що значення змінної <code>age</code> неизвестно.</p>
                    <h2><a class="main__anchor" name="znachenie-undefined" href="#znachenie-undefined">Значення «undefined»</a></h2><p>Спеціальне значення <code>undefined</code> також стоїть осібно. Воно формує тип з самого себе так само, як і<code>null</code>.</p>
                    <p>Воно означає, що «значення не було присвоєно». </p>
                    <p> Якщо змінна оголошена, але їй не присвоєно ніякого значення, то її значенням буде <code>undefined</code>:</p>
                    <pre>let age;
alert(age); // выведет "undefined"</pre>
                    <p>Технічно ми можемо присвоїти значення <code> undefined </code> будь-якої змінної:</p>
                    <pre>let age = 123;
// изменяем значение на undefined
age = undefined;
alert(age); // "undefined"</pre>
                    <p>…Але так робити не рекомендується. Зазвичай <code> null </code> використовується для присвоєння змінної «порожнього» або «невідомого» значення, а <code> undefined </code> - для перевірок, була змінна призначена. </p>
                    <h2> <a class="main__anchor" name="obekty-i-simvoly" href="#obekty-i-simvoly"> Об'єкти і символи </a> </h2> <p> Тип <code> object </code> (об'єкт) - особливий. </p>
                    <p> Всі інші типи називаються «примітивними», тому що їх значеннями можуть бути тільки прості значення (будь то рядок, або число, або щось ще). В об'єктах же зберігають колекції даних або більш складні структури. </p>
                    <p> Об'єкти займають важливе місце в мові і вимагають особливої ​​уваги. Ми розберемося з ними в розділі <a href="/object"> Об'єкти </a> після того, як дізнаємося більше про примітиви. </p>
                    <p> Тип <code> symbol </code> (символ) використовується для створення унікальних ідентифікаторів в об'єктах. Ми згадуємо тут про нього для повноти картини, вивчимо цей тип після об'єктів.</p>
                    <h2><a class="main__anchor" name="type-typeof" href="#type-typeof">Оператор typeof</a></h2><p>Оператор <code>typeof</code> повертає тип аргументу. Це корисно, коли ми хочемо обробляти значення різних типів по-різному або просто хочемо зробити перевірку.</p>
                    <p>У него есть две синтаксические формы:</p>
                    <ol>
                        <li>Синтаксис оператора: <code>typeof x</code>.</li>
                        <li>Синтаксис функції: <code>typeof(x)</code>.</li>
                    </ol>
                    <p>Іншими словами, він працює з дужками або без дужок. Результат однаковий. </p>
                    <p>Дзвінок <code> typeof x </code> повертає рядок з ім'ям типу:</p>
                    <pre>typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
<em>typeof Math // "object"  (1) </em>
<em>typeof null // "object"  (2) </em>
<em>typeof alert // "function"  (3) </em></pre>
                    <p>Останні три рядки потребують поясненні:</p>
                    <ol>
                        <li><code>Math</code> — це вбудований об'єкт, який надає математичні операції і константи. Ми розглянемо його докладніше в розділі <a href="/number"> Числа </a>. Тут він служить лише прикладом об'єкта. </li>
                        <li> Результатом виклику <code> typeof null </code> є <code> "object" </code>. Це офіційно визнана помилка в <code> typeof </code>, ведуча початок з часів створення JavaScript і збережена для сумісності. Звичайно, <code> null </code> не є об'єктом. Це спеціальне значення з окремим типом. </li>
                        <li> Дзвінок <code> typeof alert </code> повертає <code> "function" </code>, тому що <code> alert </code> є функцією. Ми вивчимо функції в наступних розділах, де заодно побачимо, що в JavaScript немає спеціального типу «функція». Функції відносяться до об'єктного типу. Але <code> typeof </code> обробляє їх особливим чином, повертаючи <code> "function" </code>. Так теж повелося від створення JavaScript. Формально це невірно, але може бути зручним на практиці.</li>
                    </ol>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Итого</a></h2><p>В JavaScript є 8 основних типів.</p>
                    <ul>
                        <li><code>number</code> для будь-яких чисел: цілочисельних або чисел з плаваючою точкою; цілочисельні значення обмежені діапазоном <code> ± (2 <sup> 53 </sup> -1) </code>. </li>
                        <li> <code> bigint </code> для цілих чисел довільної довжини. </li>
                        <li> <code> string </code> для рядків. Рядок може містити нуль або більше символів, немає окремого символьного типу. </li>
                        <li> <code> boolean </code> для <code> true </code> /<code> false </code>. </li>
                        <li> <code> null </code> для невідомих значень - окремий тип, який має одне значення <code> null </code>. </li>
                        <li> <code> undefined </code> для неприсвоєння значень - окремий тип, який має одне значення <code> undefined </code>. </li>
                        <li> <code> object </code> для більш складних структур даних. </li>
                        <li> <code> symbol </code> для унікальних ідентифікаторів.</li>
                    </ul>
                    <p>Оператор <code>typeof</code> дозволяє нам побачити, який тип даних збережений в змінній.</p>
                    <ul>
                        <li>Має дві форми: <code>typeof x</code> или <code>typeof(x)</code>.</li>
                        <li>Повертає рядок з ім'ям типу. наприклад,<code>"string"</code>.</li>
                        <li>Для <code>null</code> повертається <code>"object"</code> – це помилка в мові, насправді це не об'єкт.</li>
                    </ul>
                    <p>У наступних розділах ми сконцентруємося на примітивних значеннях, а коли познайомимося з ними, перейдемо до об'єктів.</p>
               

                <h3 id='dataTransformation'>Перетворення типів</h3>
                    <p>Найчастіше оператори і функції автоматично призводять передані їм значення до потрібного типу. </p>
                    <p> Наприклад, <code> alert </code> автоматично перетворює будь-яке значення до рядка. Математичні оператори перетворюють значення до чисел. </p>
                    <p> Є також випадки, коли нам потрібно явно перетворити значення в очікуваний тип. </p>
                        <div class="important__header"> <span class="important__type"> Поки що ми не говоримо про об'єкти </span> </div>
                        <div class="important__content">
                            <p> В цьому розділі ми не торкаємося об'єктів. Спочатку ми розберемо перетворення примітивних значень. Ми розберемо перетворення об'єктів пізніше, в розділі <a href="/object-toprimitive"> Перетворення об'єктів в примітиви</a>.</p>
                    </div>
                    <h2><a class="main__anchor" name="strokovoe-preobrazovanie" href="#strokovoe-preobrazovanie">Cтрокове перетворення</a></h2><p>Строкове перетворення відбувається, коли потрібне представлення чого-небудь у вигляді рядка.</p>
                    <p>Наприклад, <code>alert(value)</code> перетворює значення до рядка.</p>
                    <p>Також ми можемо використовувати функцію <code> String (value) </code>, щоб перетворити значення до рядка:</p>
                    <pre>let value = true;
alert(typeof value); // boolean
<em>value = String(value); // теперь value это строка "true"
alert(typeof value); // string</em></pre>
                     <p>Перетворення відбувається очевидним чином. <Code> false </Code> стає <code> "false" </code>, <code> null </code> стає <code>"null"</code> и т.п.</p>
                    <h2><a class="main__anchor" name="chislennoe-preobrazovanie" href="#chislennoe-preobrazovanie">Чисельне перетворення </a></h2><p> Чисельне перетворення відбувається в математичних функціях і виразах.</p>
                    <p>Наприклад, коли операція ділення <code> / </code> застосовується не до числа:</p>
                    <pre>alert( "6" / "2" ); // 3, строки преобразуются в числа</pre>
                    <p>Ми можемо використовувати функцію <code> Number (value) </code>, щоб явно перетворити <code>value</code> к числу:</p>
                    <pre>let str = "123";
alert(typeof str); // string
let num = Number(str); // становится числом 123
alert (typeof num); // number</pre>
                    <p>Явне перетворення часто застосовується, коли ми очікуємо отримати число з строкового контексту, наприклад з текстових полів форм. </p>
                    <p> Якщо рядок не може бути явно приведена до числа, то результатом перетворення буде<code>NaN</code>. Например:</p>
                    <pre>let age = Number("Любая строка вместо числа");
alert(age); // NaN, преобразование не удалось</pre>
                    <p>Правила численного перетворення:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Значення</th>
                                <th>Перетворюються в…</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>undefined</code></td>
                                <td><code>NaN</code></td>
                            </tr>
                            <tr>
                                <td><code>null</code></td>
                                <td><code>0</code></td>
                            </tr>
                            <tr>
                                <td><code>true&nbsp;/&nbsp;false</code></td>
                                <td><code>1</code> / <code>0</code></td>
                            </tr>
                            <tr>
                                <td><code>string</code></td>
                                <td>Пробільні символи по краях обрізаються. Далі, якщо залишається порожній рядок, то отримуємо <code>0</code>, інакше з непорожній рядки «зчитується» число. При помилку результат <code>NaN</code>.</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Приклади:</p><pre>alert( Number("   123   ")); // 123
alert( Number("123z"));      // NaN (ошибка чтения числа на месте символа "z")
alert( Number(true));        // 1
alert( Number(false));       // 0</pre>
                    <p>Врахуйте, що <code> null </code> і <code> undefined </code> поводяться по-різному. Так, <code> null </code> стає нулем, тоді як <code> undefined </code> приводиться до <code> NaN </code>. </p>
                    <p> Більшість математичних операторів також проводить дане перетворення, як ми побачимо в наступному розділі. </p>
                    <h2> <a class="main__anchor" name="logicheskoe-preobrazovanie" href="#logicheskoe-preobrazovanie"> Логічне перетворення </a></h2><p> Логічне перетворення найпростіше. </p>
                    <p> Відбувається в логічних операціях (пізніше ми познайомимося з умовними перевірками і подібними конструкціями), але також може бути виконано явно за допомогою функції <code> Boolean (value) </code>. </p>
                    <p> Правило перетворення:</p>
                    <ul>
                        <li>Значення, які інтуїтивно «порожні», на кшталт <code> 0 </code>, порожнього рядка, <code> null </code>, <code> undefined </code> і <code> NaN </code>, стають <code> false </code>. </li>
                        <li> Всі інші значення стають <code>true</code>.</li>
                    </ul>
                    <p>Наприклад:</p>
                    <pre>alert(Boolean(1) ); // true
alert( Boolean(0) ); // false
alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false</pre>
                       <div class="important__header"><span class="important__type">Зауважимо, що рядок з нулем <code>"0"</code> — это <code>true</code></span></div>
                       <p>Деякі мови (наприклад, PHP) сприймають рядок <code> "0" </code> як <code> false </code>. Але в JavaScript, якщо рядок не порожня, то вона завжди <code>true</code>.</p>
                       <pre>alert( Boolean("0") ); // true
alert(Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)</pre>                                    
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Iтого</a></h2><p>Існує 3 найбільш широко використовуваних перетворення: строкове, чисельне і логічне. </p>
                    <p> <strong> <code> Строкове </code> </strong> - Відбувається, коли нам потрібно щось вивести. Може бути викликано за допомогою <code> String (value) </code>. Для примітивних значень працює очевидним чином. </p>
                    <p> <strong> <code> Чисельне </code> </strong> - Відбувається в математичних операціях. Може бути викликано за допомогою <code> Number (value) </code>. </p>
                    <p> Перетворення підпорядковується правилам:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Значеня</th>
                                <th>Становиться…</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>undefined</code></td>
                                <td><code>NaN</code></td>
                            </tr>
                            <tr>
                                <td><code>null</code></td>
                                <td><code>0</code></td>
                            </tr>
                            <tr>
                                <td><code>true&nbsp;/&nbsp;false</code></td>
                                <td><code>1 / 0</code></td>
                            </tr>
                            <tr>
                                <td><code>string</code></td>
                                <td>Пробільні символи по краях обрізаються. Далі, якщо залишається порожній рядок, то отримуємо <code>0</code>, інакше з непорожній рядки «зчитується» число. При помилку результат <code>NaN</code>.</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong><code>Логічне</code></strong> – Відбувається в логічних операціях. Може бути викликано за допомогою <code>Boolean(value)</code>.</p>
                    <p>Підкоряється правилам:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Значеня</th>
                                <th>>Становиться…</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>""</code></td>
                                <td><code>false</code></td>
                            </tr>
                            <tr>
                                <td>будь-яке інше значення</td>
                                <td><code>true</code></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Більшу частину з цих правил легко зрозуміти і запам'ятати. Особливі випадки, в яких часто припускаються помилок:</p>
                    <ul>
                        <li><code>undefined</code> при чисельному перетворенні стає <code>NaN</code>, не <code>0</code>.</li>
                        <li><code>"0"</code> і рядки з одних прогалин типу <code>" "</code> при логічному перетворенні завжди <code>true</code>.</li>
                    </ul>
                    <p>У цьому розділі ми не говорили про об'єкти. Ми повернемося до них пізніше, в главі <a href="/object-toprimitive">Перетворення об'єктів в примітиви </a>, присвяченій тільки об'єктам, відразу після того, як дізнаємося більше про основи JavaScript.</p>


                <h3 id='baseMatematicOperations'>Базові перетворення, математика</h3>

                    <p>Багато операторів знайомі нам ще зі школи: додавання <code> + </code>, множення <code> * </code>, віднімання <code> - </code> і так далі. </p>
                    <p> В цьому розділі ми почнемо з простих операторів, а потім сконцентруємося на специфічних для JavaScript аспектах, які не проходять в шкільному курсі арифметики.</p>
                    <h2><a class="main__anchor" name="terminy-unarnyy-binarnyy-operand" href="#terminy-unarnyy-binarnyy-operand">Терміни: «унарний», «бінарний», «операнд» </a></h2><p> Перш, ніж ми рушимо далі, давайте розберемося з термінологією.</p>
                    <ul>
                        <li>
                            <p><em>Операнд </em> - те, до чого застосовується оператор. Наприклад, в множенні <code> 5 * 2 </code> є два операнда: лівий операнд дорівнює <code> 5 </code>, а правий операнд дорівнює <code> 2 </code>. Іноді їх називають «аргументами» замість «операндів».</p>
                        </li>
                        <li>
                            <p><em>Унарним </em> називається оператор, який застосовується до одного операнду. Наприклад, оператор унарний мінус <code> "-" </code> змінює знак числа на протилежний:</p>
                            <pre>let x = 1;
<em>x = -x;</em>
alert( x ); // -1, применили унарный минус<</pre>                             
                        </li>
                        <li>
                            <p><em>Бінарним </em> називається оператор, який застосовується до двох операндам. Той же мінус існує і в бінарній формі:</p>
                            <pre>let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения</pre>
                    <p>Формально, в останніх прикладах ми говоримо про двох різних операторах, що використовують один символ: оператор заперечення (унарний оператор, який звертає знак) і оператор віднімання (бінарний оператор, який віднімає одне число з іншого).</p>
                        </li>
                    </ul>
                    <h2><a class="main__anchor" name="matematika" href="#matematika">Математика</a></h2><p>Підтримуються наступні математичні оператори:</p>
                    <ul>
                        <li> Додавання <code> + </code>, </li>
                        <li> Віднімання <code> - </code>, </li>
                        <li> Множення <code> * </code>, </li>
                        <li> Ділення <code> / </code>, </li>
                        <li> Взяття залишку від ділення <code>% </code>, </li>
                        <li> Піднесення до степеня
                    </ul>
                    <p>Перші чотири оператори очевидні, а про <code>% </code> і <code> ** </code> варто сказати кілька слів.</p>
                    <h4><a class="main__anchor" name="vzyatie-ostatka" href="#vzyatie-ostatka">Взяття залишку% </a></h4><p> Оператор взяття залишку <code>% </code>, незважаючи на позначення, ніякого відношення до відсотків не має.</p>
                    <p>Результат <code>a % b</code> – это <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%BC">остаток</a> від цілочисельного ділення <code>a</code> на <code>b</code>.</p>
                    <p>Наприклад:</p>
                    <pre>alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert(8 %3 ); // 2, остаток от деления 8 на 3</pre>
                    <h4><a class="main__anchor" name="vozvedenie-v-stepen" href="#vozvedenie-v-stepen">Зведення в ступінь **</a></h4><p>У вираженні <code> a ** b </code> оператор піднесення до степеня примножує <code>a</code> на само себя <code>b</code> раз.</p>
                    <p>Наприклад:</p>
                    <pre>alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)</pre>
                    <p>Математично, оператор працює і для нецілих чисел. Наприклад, квадратний корінь є зведенням до степеня<code>1/2</code>:</p>
                    <pre>alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)</pre>
                    <h2><a class="main__anchor" name="slozhenie-strok-pri-pomoschi-binarnogo" href="#slozhenie-strok-pri-pomoschi-binarnogo">Додавання рядків за допомогою бінарного +</a></h2><p>Давайте розглянемо більш доступного режиму операторів JavaScript, які виходять за рамки шкільної арифметики.</p>
                    <p>Зазвичай за допомогою плюса <code> '+' </code> складають числа. </p>
                    <p> Але якщо бінарний оператор <code> '+' </code> застосувати до рядків, то він їх об'єднує в одну:</p>
                    <pre>let s = "моя" + "строка";
alert(s); // моя строка</pre>
                    <p>Зверніть увагу, якщо хоча б один операнд є рядком, то другий буде також перетворений в рядок.</p>
                    <p>Наприклад:</p>
                    <pre>alert( '1' + 2 ); // "12"
alert( 2 + '1' );// "21"</pre>
                     <p>Як бачите, не важливо, перший або другий операнд є рядком. </p>
                    <p> Ось приклад складніше:</p>
                    <pre>alert(2 + 2 + '1'); // будет "41", а не "221"</pre>
                    <p>Тут оператори працюють один за іншим. Перший <code> + </code> складає два числа і повертає <code> 4 </code>, потім наступний <code> + </code> об'єднує результат з рядком, виробляючи дію <code> 4 + '1' = 41 </code>. </p>
                    <p> Додавання і перетворення рядків - це особливість бінарного плюса <code> + </code>. Інші арифметичні оператори працюють тільки з числами і завжди перетворять операнди в числа. </p>
                    <p> Наприклад, віднімання і ділення:</p>
                    <pre>alert(6 - '2' ); // 4, '2' приводится к числу
alert('6' / '2' ); // 3, оба операнда приводятся к числам</span></code></pre>
                    <h2><a class="main__anchor" name="privedenie-k-chislu-unarnyy" href="#privedenie-k-chislu-unarnyy">Приведення до числа, унарний +</a></h2><p>Плюс <code>+</code> існує в двох формах: бінарної, яку ми використовували вище, і унарною.</p>
                    <p>Унарний, тобто застосований до одного значення, плюс <code> + </code> нічого не робить з числами. Але якщо операнд не числиться, унарний плюс перетворює його в число.</p>
                    <p>Напиклад:</p>
                    <pre>// Не влияет на числа
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
<em>// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0</em></pre>
                    <p>Насправді це те ж саме, що і <code> Number (...) </code>, тільки коротше. </p>
                    <p> Необхідність перетворювати рядки в числа виникає дуже часто. Наприклад, зазвичай значення полів HTML-форми - це рядки. А що, якщо їх потрібно, наприклад, скласти? </p>
                    <p> Бінарний плюс складе їх як рядки:</p>
                    <pre>let apples = "2";>
let oranges = "3";
alert( apples >+ oranges ); // "23", так как бинарный плюс объединяет строки</pre>
 <p>Тому використовуємо унарний плюс, щоб перетворити до числа:</p>
                   <pre>let apples = "2";
let oranges = "3";
<em>// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5</em>
// более длинный вариант</pre>
                    <p>З точки зору математика, такий достаток плюсів виглядає дивним. Але з точки зору програміста тут немає нічого особливого: спочатку виконаються унарні плюси, які приведуть рядки до чисел, а потім бінарний <code> '+' </code> їх складе. </p>
                    <p> Чому унарні плюси виконалися до бінарного складання? Як ми зараз побачимо, справа в їх пріоритеті. </p>
                    <h2> <a class="main__anchor" name="prioritet-operatorov" href="#prioritet-operatorov"> Пріоритет операторів </a></h2>
                    <p> В тому випадку, якщо не має декілька операторів - порядок їх виконання визначається <em> пріоритетом </em>, або, іншими словами, існує певний порядок виконання операторів. </p>
                    <p> Зі школи ми знаємо, що множення в вираженні <code> 1 + 2 * 2 </code> виконається раніше складання. Це як раз і є «пріоритет». Кажуть, що множення має вищий пріоритет, ніж складання. </p>
                    <p> Дужки важливіше, ніж пріоритет, так що, якщо ми не задоволені порядком за замовчуванням, ми можемо використовувати їх, щоб змінити пріоритет. Наприклад, написати <code> (1 + 2) * 2 </code>. </p>
                    <p> В JavaScript багато операторів. Кожен оператор має відповідний номер пріоритету. Той, у кого це число більше, - виконається раніше. Якщо пріоритет однаковий, то порядок виконання - зліва направо. </p>
                    <p> Уривок з <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"> таблиці пріоритетів </a> (немає необхідності все запам'ятовувати, зверніть увагу, що пріоритет унарних операторів вище, ніж відповідних бінарних):</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Приоритет</th>
                                <th>Название</th>
                                <th>Обозначение</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>…</td>
                                <td>…</td>
                                <td>…</td>
                            </tr>
                            <tr>
                                <td>17</td>
                                <td>унарный плюс</td>
                                <td><code>+</code></td>
                            </tr>
                            <tr>
                                <td>17</td>
                                <td>унарный минус</td>
                                <td><code>-</code></td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>возведение в степень</td>
                                <td><code>**</code></td>
                            </tr>
                            <tr>
                                <td>15</td>
                                <td>умножение</td>
                                <td><code>*</code></td>
                            </tr>
                            <tr>
                                <td>15</td>
                                <td>деление</td>
                                <td><code>/</code></td>
                            </tr>
                            <tr>
                                <td>13</td>
                                <td>сложение</td>
                                <td><code>+</code></td>
                            </tr>
                            <tr>
                                <td>13</td>
                                <td>вычитание</td>
                                <td><code>-</code></td>
                            </tr>
                            <tr>
                                <td>…</td>
                                <td>…</td>
                                <td>…</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>присваивание</td>
                                <td><code>=</code></td>
                            </tr>
                            <tr>
                                <td>…</td>
                                <td>…</td>
                                <td>…</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Так як «унарний плюс» має пріоритет <code> 17 </code>, який вище, ніж <code> 13 </code> у «складання» (бінарний плюс), то у виразі <code> "+ apples + + oranges "</code> спочатку виконаються унарні плюси, а потім додавання. </p>
                    <h2> <a class="main__anchor" name="prisvaivanie" href="#prisvaivanie"> Присвоєння </a></h2><p> Давайте відзначимо, що в таблиці пріоритетів також є оператор присвоювання <code> = </code>. У нього один з найнижчих пріоритетів: <code> 3 </code>. </p>
                    <p> Саме тому, коли змінної щось привласнюють, наприклад, <code> x = 2 * 2 + 1 </code>, то спочатку виконається арифметика, а вже потім відбудеться присвоювання <code> = </code> зі збереженням результату в <code>x</code>.</p>
                    <pre>let x = 2 * 2 + 1;
alert( x ); // 5</pre>
                    <h4><a class="main__anchor" name="prisvaivanie-vozvraschaet-znachenie" href="#prisvaivanie-vozvraschaet-znachenie">Присвоєння = повертає значення </a> </h4> <p> Той факт, що <code> = </code> є оператором, а не «магічною» конструкцією мови, має цікаві наслідки. </p>
                    <p> Більшість операторів в JavaScript повертають значення. Для деяких це очевидно, наприклад додавання <code> + </code> або множення <code> * </code>. Але і оператор присвоювання не є винятком. </p>
                    <p> Дзвінок <code> x = value </code> записує <code> value </code> в <code> x </code> <em> і повертає його </em>. </p>
                    <p> Завдяки цьому присвоювання можна використовувати як частину більш складного вираження:</p>
                    <pre>let a = 1;
let b = 2;
<em>let c = 3 - (a = b + 1);</em>
alert( a ); // 3
alert( c ); // 0</pre>
                    <p>В наведеному вище прикладі результатом <code> (a = b + 1) </code> буде значення, яке присвоюється змінної <code> a </code> (тобто <code> 3 </code>). Потім воно використовується для подальших обчислень. </p>
                    <p> Кумедне застосування привласнення, чи не так? Нам потрібно розуміти, як це працює, тому що іноді це можна побачити в JavaScript-бібліотеках. </p>
                    <p> Однак писати самим в такому стилі не рекомендується. Такі трюки не зроблять ваш код зрозумілішим або читабельним.</p>
                    <h4><a class="main__anchor" name="prisvaivanie-po-tsepochke" href="#prisvaivanie-po-tsepochke">Присвоєння по ланцюжку</a></h4><p>Розглянемо ще одну цікаву можливість: ланцюжок присвоювання.</p>
                    <pre>let a, b, c;
<em>a = b = c = 2 + 2;</em>
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4</pre>
                    <p>Таке присвоювання працює справа наліво. Спочатку обчислюється саме праве вираз <code> 2 + 2 </code>, і потім результат присвоюється змінним зліва: <code> c </code>, <code> b </code> і <code> a </code>. В кінці у всіх змінних буде одне значення. </p>
                    <p> Знову-таки, щоб код читався легше, краще розділяти подібні конструкції на кілька рядків:</p>
                    <pre>c = 2 + 2;
b = c;
a = c;</pre>
                    <p>Користь від такого стилю особливо відчувається при швидкому перегляді коду.</p>
                    <h2><a class="main__anchor" name="sokraschyonnaya-arifmetika-s-prisvaivaniem" href="#sokraschyonnaya-arifmetika-s-prisvaivaniem">Скорочена арифметика з привласненням </a></h2><p> Часто потрібно застосувати оператор до змінної і зберегти результат в ній же.</p>
                    <p>Наприклад:</p>
                    <pre>let n = 2;
n = n + 5;
n = n * 2;</pre>
                     <p>Цей запис можна вкоротити за допомогою суміщених операторів <code>+=</code> и <code>*=</code>:</p>
                     <pre>let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)
alert( n ); // 14</pre>
                    <p>Подібні короткі форми запису існують для всіх арифметичних і побітових операторів: <code> / = </code>, <code> - = </code> і так далі. </p>
                    <p> Дзвінок з привласненням має в точності такий же пріоритет, як звичайне присвоювання, тобто виконається після більшості інших операцій:</p>
                   <pre>let n = 2;
n *= 3 + 5;
alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)</pre>
                    <h2><a class="main__anchor" name="inkrement-dekrement" href="#inkrement-dekrement">Інкремент/декремент</a></h2><!-- Не получается использовать -- в заголовке, так как парсер превращает -- в длинное тире – -->
                    <p>Однією з найбільш частих числових операцій є збільшення або зменшення на одиницю. </p>
                    <p> Для цього існують навіть спеціальні оператори:</p>
                    <ul>
                        <li>
                            <p><strong>Інкремент</strong> <code>++</code> збільшує змінну на 1:</p>
                            <pre>let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
alert( counter ); // 3</pre>                                   
                        </li>
                        <li>
                            <p><strong>Декремент</strong> <code>--</code> зменшує змінну на 1:</p>
                            <pre>let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
alert( counter ); // 1</pre>                                    
                    </li>
                    </ul>
                   <div class="important__header"><span class="important__type">Важливо:</span></div>
                     <p>Інкремент/декремент можна застосувати тільки до змінної. Спроба використовувати його на значенні, типу 5 ++, призведе до помилки.</p>
                     <p>Оператори <code>++</code> и <code>--</code> можуть бути розташовані не тільки після, але і до змінної.</p>
                    <ul>
                        <li>Коли оператор йде після змінної - це «Постфіксний форма»: <code> counter ++ </code>. </li>
                        <li> «префіксних форма» - це коли оператор іде перед змінної: <code> ++ counter </code>. </li>
                    </ul>
                    <p> Обидві ці інструкції роблять одне і те ж: збільшують <code> counter </code> на <code> 1 </code>. </p>
                    <p> Чи є різниця між ними? Так, але побачити її ми зможемо, тільки якщо будемо використовувати значення, яке повертають <code> ++ / - </code>. </p>
                    <p> Давайте з'ясуємо цей момент. Як ми знаємо, всі оператори повертають значення. Оператори інкремента / декремента не виняток. Префіксная форма повертає нове значення, в той час як Постфіксний форма повертає старе (до збільшення / зменшення числа). </p>
                    <p> Щоб побачити різницю, ось невеликий приклад:</p>
                    <pre>let counter = 1;
let a = ++counter; // (*)
alert(a); // <em class="inline-highlight">2</em></pre>
                    <p>У рядку <code> (*) </code> <em> префиксная </em> форма <code> ++ counter </code> збільшує <code> counter </code> і повертає нове значення <code> 2 </code>. Так що <code> alert </code> покаже <code> 2 </code>. </p>
                    <p> Тепер подивимося на Постфіксний форму:</p>
                    <pre>let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++
alert(a); // <em class="inline-highlight">1</em></pre>
                    <p>У рядку <code> (*) </code> <em> Постфіксний </em> форма <code> counter ++ </code> також збільшує <code> counter </code>, але повертає <em> старе </em> значення (яке було до збільшення). Так що <code> alert </code> покаже <code> 1 </code>. </p>
                    <p> Підіб'ємо підсумки:</p>
                    <ul>
                        <li>
                            <p>Якщо результат оператора не використовується, а потрібно тільки збільшити / зменшити змінну, тоді без різниці, яку форму використовувати:</p>
                            <pre>let counter = 0;
counter++;
++counter;
alert( counter ); // 2, обе строки сделали одно и то же</pre>
                        </li>
                        <li>
                            <p>Якщо хочеться тут же використовувати результат, то потрібна префиксная форма:</p>
                            <pre>let counter = 0;
alert( ++counter ); // 1</pre>
                        </li>
                        <li>
                            <p> Якщо потрібно збільшити і при цьому отримати значення змінної <em> до збільшення </em> - потрібна Постфіксний форма:</p>
                            <pre>let counter = 0;
alert( counter++ ); // 0</pre>                              
                     </li>
                    </ul>
                       <div class="important__header"><span class="important__type">Інкремент / декремент можна використовувати в будь-яких виразах </span> </div>
                            <p> Оператори <code> ++ / - </code> можуть також використовуватися всередині виразів. Їх пріоритет вище, ніж у більшості інших арифметичних операцій.</p>
                            <p>Наприклад:</p>
                              <pre>let counter = 1;
alert( 2 * ++counter ); // 4</pre>
                            <p>Порівняйте з:</p>
                            <pre>let counter = 1;
alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение</pre>
                            <p>Хоча технічно тут все в порядку, такий запис зазвичай робить код менш читабельним. Один рядок виконує безліч дій - недобре. </p>
                            <p> При побіжному читанні коду можна з легкістю пропустити такий <code> counter ++ </code>, і буде неочевидно, що змінна збільшується. </p>
                            <p> Краще використовувати стиль «один рядок - одне дію»:</p>
                            <pre>let counter = 1;
alert( 2 * counter );
counter++;</pre>                                 
                    <h2><a class="main__anchor" name="pobitovye-operatory" href="#pobitovye-operatory">Побітові оператори </a> </h2> <p> Побітові оператори працюють з 32-розрядними цілими числами (при необхідності приводять до них), на рівні їх внутрішнього двійкового представлення. </p>
                    <p> Ці оператори не є чимось специфічним для JavaScript, вони підтримуються в більшості мов програмування. </p>
                    <p> Підтримуються наступні побітові оператори:</p>
                    <ul>
                        <li>AND(і) ( <code>&amp;</code> )</li>
                        <li>OR(або) ( <code>|</code> )</li>
                        <li>XOR ( <code>^</code> )</li>
                        <li>NOT(не) ( <code>~</code> )</li>
                        <li>LEFT SHIFT(лівий сдвиг) ( <code>&lt;&lt;</code> )</li>
                        <li>RIGHT SHIFT(правий сдвиг) ( <code>&gt;&gt;</code> )</li>
                        <li>ZERO-FILL RIGHT SHIFT(правий сдвиг с заповненням нулями) ( <code>&gt;&gt;&gt;</code> )</li>
                    </ul>
                    <p>Вони використовуються рідко, коли виникає необхідність оперувати з числами на дуже низькому (побітового) рівні. В найближчому часі вони нам не знадобляться, тому що веб-розробники рідко до них вдаються, хоча в деяких сферах (наприклад, в криптографії) вони корисні. Можете прочитати <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2% D1% 8B% D0% B5_% D0% BF% D0% BE% D1% 80% D0% B0% D0% B7% D1% 80% D1% 8F% D0% B4% D0% BD% D1% 8B% D0% B5_% D0% BE% D0% BF% D0% B5% D1% 80% D0% B0% D1% 82% D0% BE% D1% 80% D1% 8B "> розділ про них </a> на MDN, коли виникне реальна необхідність. </p>
                    <h2> <a class="main__anchor" name="operator-zapyataya" href="#operator-zapyataya"> Оператор «кома» </a></h2><p> Оператор «кома» (<code>, </code>) рідко застосовується і є одним з найбільш незвичайних. Іноді він використовується для написання більш короткого коду, тому нам потрібно знати його, щоб розуміти, що при цьому відбувається. </p>
                    <p> Оператор «кома» надає нам можливість обчислювати кілька виразів, розділяючи їх комою <code>, </code>. Кожен вираз виконується, але повертається результат тільки останнього.</p>
                    <p>Наприклад:</p>
                    <pre><em>let a = (1 + 2, 3 + 4);</em>
alert( a ); // 7 (результат вычисления 3 + 4)<</pre>
                    <p>Перший вираз <code> 1 + 2 </code> виконується, а результат відкидається. Потім йде <code> 3 + 4 </code>, вираз виконується і повертається результат.</p>
                    <div class="important__header"><span class="important__type">Кома має дуже низький пріоритет </span> </div>
                        <div class="important__content">
                            <p> Будь ласка, зверніть увагу, що оператор <code>, </code> має дуже низький пріоритет, нижче <code> = </code>, тому дужки важливі в наведеному вище прикладі. </p>
                            <p> Без них в <code> a = 1 + 2, 3 + 4 </code> спочатку виконається <code> + </code>, підсумовуючи числа в <code> a = 3, 7 </code>, потім оператор присвоювання <code> = </code> присвоїть <code> a = 3 </code>, а то, що йде далі, буде проігноровано. Все так же, як в <code>(a = 1 + 2), 3 + 4</code>.</p>
                        </div>
                    <p>Навіщо нам оператор, який відкидає все, крім останнього виразу? </p>
                    <p>Іноді його використовують в складі більш складних конструкцій, щоб зробити кілька дій в одному рядку. </p>
                    <p> Наприклад:</p>
                    <pre>// три операции в одной строке
<em>for (a = 1, b = 3 c = a * b</em>; a &lt; 10; a++) {
                                ...
}</pre>
                     <p>Такі трюки використовуються в багатьох JavaScript-фреймворку. Ось чому ми згадуємо їх. Але зазвичай вони не покращують читабельність коду, тому варто добре подумати, перш ніж їх використовувати.</p>
        

                <h3 id='comparisonOperators'>Оператори порівняння</h3>

                <div itemprop="articleBody">
                    <p>Багато операторів порівняння відомі нам з математики. </p>
                    <p> В JavaScript вони записуються так:</p>
                    <ul>
                        <li>Більше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.</li>
                        <li>Більше/меньше або равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.</li>
                        <li>Равно: <code>a == b</code>. Зверніть увагу, для порівняння використовується подвійний знак рівності <code> == </code>. Один знак рівності <code> a = b </code> означав би присвоювання. </li>
                        <li> Не дорівнює. В математиці позначається символом <code> ≠ </code>, але в JavaScript записується як <code>a != b</code>.</li>
                    </ul>
                    <p> У цьому розділі ми більше дізнаємося про те, які бувають порівняння, як мова з ними працює і до яких несподіванок ми повинні бути готові. </p>
                    <p> В кінці ви знайдете хороший рецепт того, як уникати «примх» порівняння в JavaScript.</p>
                    <h2><a class="main__anchor" name="rezultat-sravneniya-imeet-logicheskiy-tip" href="#rezultat-sravneniya-imeet-logicheskiy-tip">Результат порівняння має логічний тип</a></h2><p>Всі оператори порівняння повертають значення логічного типу:</p>
                    <ul>
                        <li><code>true</code> – означає «так», «вірно», «істина».</li>
                        <li><code>false</code> – означає «ні», «не так», «брехня».</li>
                    </ul>
                    <p>Наприклад:</p>
                    <pre>alert( 2 &gt; 1 ); // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)</pre>
                  <p>Результат порівняння можна привласнити змінної, як і будь-яке значення:</p>
                  <pre>let result = 5 &gt; 4; // результат сравнения присваивается переменной result
alert( result ); // true</pre>
                    <h2><a class="main__anchor" name="sravnenie-strok" href="#sravnenie-strok">Порівняння рядків </a> </h2> <p> Щоб визначити, що один рядок більше другий, JavaScript використовує «алфавітний» або «словниковий» порядок. </p>
                    <p> Іншими словами, рядки порівнюються посимвольний.</p>
                    <p>Наприклад:</p>
                   <pre>alert( 'Я'&gt; 'А' ); // true
alert('Коты' &gt; 'Кода' ); // true
alert('Сонный' &gt; 'Сон' ); // true</pre>
                    <p>Алгоритм порівняння двох рядків досить простий:</p>
                    <ol>
                        <li>Спочатку порівнюються перші символи рядків. </li>
                        <li> Якщо перший символ першого рядка більше (менше), ніж перший символ другої, то перший рядок більше (менше) другий. Порівняння завершено. </li>
                        <li> Якщо перші символи рівні, то таким же чином порівнюються вже другі символи рядків. </li>
                        <li> Порівняння триває, поки не закінчиться одна з рядків. </li>
                        <li> Якщо обидві рядки закінчуються одночасно, то вони рівні. Інакше, більшою вважається більш довгий рядок.</li>
                    </ol>
                    <p>У прикладах вище порівняння <code>'Я' &gt; 'А'</code> завершиться на першому кроці, тоді як рядки <code>'Котb'</code> и <code>'Кода'</code> порівнюватимуться посимвольний:</p>
                    <ol>
                        <li><code>К</code> равна <code>К</code>.</li>
                        <li><code>о</code> равна <code>о</code>.</li>
                        <li><code>т</code> быльше, ніж <code>д</code>. На цьому порівняння закінчується. Перший рядок більше.</li>
                    </ol>
                     <div class="important__header"><span class="important__type">Використовується кодування Unicode, а не справжній алфавіт </span> </div>
                        <div class="important__content">
                            <p> Наведений вище алгоритм порівняння схожий на алгоритм, який використовується в словниках і телефонних книгах, але між ними є і відмінності. </p>
                            <p> Наприклад, в JavaScript має значення регістр символів. Велика літера <code> "A" </code> не дорівнює рядкової <code> "a" </code>. Яка ж з них більше? Рядкова <code> "a" </code>. Чому? Тому що малі літери мають більший код у внутрішній таблиці кодування, яку використовує JavaScript (Unicode). Ми ще поговоримо про внутрішньому поданні рядків і його вплив в главі <a href="/string">Строки</a>.</p>
                       </div>
                    </div>
                    <h2><a class="main__anchor" name="sravnenie-raznyh-tipov" href="#sravnenie-raznyh-tipov">Порівняння різних типів </a> </h2> <p> При порівнянні значень різних типів JavaScript призводить кожне з них до числа.</p>
                    <p>Наприклад:</p>
                    <pre>alert( '2' &gt; 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1</pre>
                    <p>Логическое значение <code>true</code> стає <code>1</code>, а <code>false</code> – <code>0</code>.</p>
                    <p>Например:</p>
                    <pre>alert( true == 1 ); // true
alert( false == 0 ); // true</pre>
                       <div class="important__header"><span class="important__type">Забавне слідство</span></div>
                        <div class="important__content">
                            <p>Можлива наступна ситуація:</p>
                            <ul>
                                <li>Два значення рівні. </li>
                                <li> Одне з них <code> true </code> як логічне значення, інше – <code>false</code>.</li>
                            </ul>
                            <p>Наприклад:</p>
                            <pre>let a = 0;
alert( Boolean(a) );// false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!</pre>
                        <p>З точки зору JavaScript, результат очікуємо. Рівність перетворює значення, використовуючи числове перетворення, тому <code> "0" </code> стає <code> 0 </code>. У той час як явне перетворення за допомогою <code> Boolean </code> використовує інший набір правил.</p>
                      </div>
                    <h2><a class="main__anchor" name="strogoe-sravnenie" href="#strogoe-sravnenie">Суворе порівняння </a> </h2> <p> Використання звичайного порівняння <code> == </code> може викликати проблеми. Наприклад, воно не відрізняє <code>0</code> от <code>false</code>:</p>
                        <pre>alert( 0 == false ); // true</pre>
                    <p>Та ж проблема з нового рядка:</p>
                      <pre>alert( '' == false ); // true</pre>
                     <p>Це відбувається через те, що операнди різних типів перетворюються оператором <code> == </code> до числа. У підсумку, і порожній рядок, і <code> false </code> стають нулем. </p>
                    <p> Як же тоді відрізняти <code> 0 </code> від <code> false </code>? </p>
                    <p> <strong> Оператор строгого рівності <code>===</code> перевіряє рівність без приведення типів. </strong> </p>
                    <p> Іншими словами, якщо <code> a </code> і <code> b </code> мають різні типи, то перевірка <code> a === b </code> негайно повертає <code> false </code> без спроби їх перетворення. </p>
                    <p> Давайте перевіримо:</p>
                    <pre>alert( 0 === false ); // false, так как сравниваются разные типы</pre>
                    <p>Ще є оператор строгої нерівності <code>! == </code>, аналогічний <code>! = </code>. </p>
                    <p> Оператор строгого рівності довше писати, але він робить код більш очевидним і залишає менше місця для помилок.</p>
                    <h2><a class="main__anchor" name="sravnenie-s-null-i-undefined" href="#sravnenie-s-null-i-undefined">Порівняння з null і undefined </a></h2><p> Поведінка <code> null </code> і <code> undefined </code> при порівнянні з іншими значеннями - особливе:</p>
                    <dl>
                        <dt>При суворому рівність <code>===</code></dt>
                        <dd>
                            <p>Ці значення різні, так як різні їх типи.</p>
                            <pre>alert( null === undefined ); // false</pre>
                       </dd>
                        <dt>При нестрогому рівність <code>==</code></dt>
                        <dd>
                            <p>Ці значення дорівнюють один одному і не рівні ніяким іншим значенням. Це спеціальне правило мови.</p>
                              <pre>alert( null == undefined ); // true</pre>
                        </dd>
                        <dt>При використанні математичних операторів і інших операторів порівняння <code>&lt; &gt; &lt;= &gt;=</code></dt>
                        <dd>
                            <p>Значення <code> null / undefined </code> перетворюються до чисел: <code> null </code> стає <code>0</code>, а <code>undefined</code> – <code>NaN</code>.</p>
                        </dd>
                    </dl>
                    <p>Подивимося, які цікаві речі трапляються, коли ми застосовуємо ці правила. І, що більш важливо, як уникнути помилок при їх використанні.</p>
                    <h4><a class="main__anchor" name="strannyy-rezultat-sravneniya-null-i-0" href="#strannyy-rezultat-sravneniya-null-i-0">Дивний результат порівняння null і 0 </a></h4><p> Порівняємо <code> null </code> з нулем:</p>
                    <pre>alert( null &gt; 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null &gt;= 0 ); // (3) <em>true</em></pre>
                    <p>З точки зору математики це дивно. Результат останнього порівняння говорить про те, що "<code> null </code> більше або дорівнює нулю", тоді результат одного з порівнянь вище повинен бути <code> true </code>, але вони обидва хибні.</p>
                    <p>Причина в тому, що Нечитка рівність і порівняння<code>&gt; &lt; &gt;= &lt;=</code> працюють по-різному. порівняння перетворять <code>null</code> в число, розглядаючи його як <code>0</code>. Тому вираз (3) <code>null &gt;= 0</code> істинно, а <code>null &gt; 0</code> помилково.</p>
                    <p>З іншого боку, для несуворого рівності <code> == </code> значень <code> undefined </code> і <code> null </code> діє особливе правило: ці значення ні до чого не наводяться, вони дорівнюють один одному і не рівні нічому іншому. Тому (2) <code>null == 0</code> помилково.</p>
                    <h4><a class="main__anchor" name="nesravnennoe-znachenie-undefined" href="#nesravnennoe-znachenie-undefined">Незрівнянне значення undefined </a> </h4> <p> Значення <code> undefined </code> незрівнянно з іншими значеннями:</p>
                    <pre>alert( undefined &gt; 0 ); // false (1)
alert(undefined &lt; 0 ); // false (2)
alert(undefined == 0 ); // false (3)</pre>
                    <p>Чому ж порівняння <code>undefined</code> з нулем завжди помилково?</p>
                    <p>На це є такі причини:</p>
                    <ul>
                        <li>Порівняння <code> (1) </code>і<code> (2) </code>повертають<code> false </code>, тому що <code>undefined</code> перетворюється в <code>NaN</code>, а <code>NaN</code> - це спеціальне числове значення, яке повертає <code>false</code> при будь-яких порівняннях. </li>
                        <li> Схожі рівність <code>(3)</code> повертає <code>false</code>, тому що <code>undefined</code> одно тільки <code>null</code>, <code>undefined</code> і нічому більше.</li>
                    </ul>
                    <h4><a class="main__anchor" name="kak-izbezhat-problem" href="#kak-izbezhat-problem">Як уникнути проблем </a></h4><p> Навіщо ми розглянули всі ці приклади? Чи повинні ми постійно пам'ятати про всі ці особливості? Не обов'язково. Згодом всі вони стануть вам знайомі, але можна уникнути проблем, якщо слідувати надійним правилами:</p>
                    <ul>
                        <li>Ставтеся дуже обережно до будь-якого порівнянні з <code>undefined / null</code>, крім випадків суворого рівності <code>===</code>.</li>
                        <li>Не використовуйте порівняння <code>&gt;= &gt; &lt; &lt;=</code> зі змінними, які можуть набувати значень <code>null/undefined</code>, хіба що ви повністю впевнені в тому, що робите. Якщо змінна може приймати ці значення, то додайте для них окремі перевірки.</li>
                    </ul>
                    <h2><a class="main__anchor" name="itogo" href="#itogo">Итого</a></h2><ul>
                        <li>Оператори порівняння повертають значення логічного типу. </li>
                        <li> Рядки порівнюються посимвольний в лексикографічному порядку. </li>
                        <li> Значення різних типів при порівнянні наводяться до числа. Винятком є порівняння за допомогою операторів суворого рівності / нерівності. </ Li>
                        <li> Значення <code>null</code> і <code>undefined </code> рівні <code>== </code> один одному і не рівні будь-якого іншого значення. </li>
                        <li> Будьте обережні при використанні операторів порівнянь на кшталт <code>&gt;</code> и <code>&lt;</code> зі змінними, які можуть набувати значень <code>null / undefined</code>. Доброю ідеєю буде зробити окрему перевірку на <code>null/undefined</code>.</li>
                    </ul>
               

                <h3 id='condition'>Умовне розгалуження: if, '?'</h3>

                <div itemprop="articleBody">
                    <p>Іноді нам потрібно виконати різні дії в залежності від умов.</p>
                    <p>Для цього ми можемо використовувати інструкцію <code>if</code> і умовний оператор <code>?</code>, який також називають оператором «знак питання».</p>
                    <h2><a class="main__anchor" name="instruktsiya-if" href="#instruktsiya-if">Інструкція «if»</a></h2><p>Інструкція <code>if(...)</code> обчислює умова в дужках і, якщо результат <code>true</code>, то виконує блок коду.</p>
                    <p>Наприклад:</p>
                    <pre>let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
<em>if (year == 2015) alert( 'Вы правы!' );</em></pre>
                    <p>В наведеному вище прикладі, умова - це проста перевірка на рівність (<code>year == 2015</code>), але воно може бути і набагато більш складним. </p>
                    <p> Якщо ми хочемо виконати більше однієї інструкції, то потрібно укласти блок коду в фігурні дужки:</p>
                     <pre class="line-numbers  language-javascript"><span class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>year <span class="token operator">==</span> <span class="token number">2015</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">"Правильно!"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">"Ви такий розумний!"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
                    <p>Ми рекомендуємо використовувати фігурні дужки <code>{}</code> завжди, коли ви використовуєте інструкцію <code>if</code>, навіть якщо виконується тільки одна команда. Це покращує читабельність коду.</p>
                    <h2><a class="main__anchor" name="preobrazovanie-k-logicheskomu-tipu" href="#preobrazovanie-k-logicheskomu-tipu">Перетворення до логічного типу</a></h2><p>Інструкція <code>if (…)</code> обчислює вираз в дужках і перетворює результат до логічного типу.</p>
                    <p>Давайте вспомним правила преобразования типов из главы <a href="/type-conversions">Перетворення типів</a>:</p>
                    <ul>
                        <li>Число <code>0</code>, порожня стрічка <code>""</code>, <code>null</code>, <code>undefined</code> и <code>NaN</code> становятся <code>false</code>. Через це їх називають «помилковими» («falsy») значеннями.</li>
                        <li>Остальные значения становятся <code>true</code>, поэтому их называют «правдивыми» («truthy»).</li>
                    </ul>
                    <p>Таким чином, код за такої умови ніколи не виконається:</p>
                    <pre>if (0) { // 0 is falsy
                   ...
}</pre>
                    <p>…а при такому - виконається завжди:</p>
                    <pre>if (1) { // 1 is truthy
                       ...
}</pre>
                  <p>Ми також можемо передати заздалегідь обчислена в змінної логічне значення в <code>if</code>, наприклад так:</p>
                  <pre>let condition = (year == 2015); // преобразуется к true или false
if (condition) {
 ...
}</pre>
                    <h2><a class="main__anchor" name="blok-else" href="#blok-else">Блок «else»</a></h2><p>Інструкція <code>if</code> може містити необов'язковий блок «else» («інакше»). Він виконується, коли умова помилкова.</p>
                    <p>Наприклад:</p>
                    <pre>let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
if (year == 2015) {
                   alert( 'Да в знаток!' );>
                  } 
else {
       alert('А вот и неправильно!' ); // любое значение, кроме 2015
     }</pre>
                    <h2><a class="main__anchor" name="neskolko-usloviy-else-if" href="#neskolko-usloviy-else-if">Кілька умов: «else if»</a></h2><p>Іноді, потрібно перевірити кілька варіантів умови. Для цього використовується блок <code>else if</code>.</p>
                    <p>Наприклад:</p>
                    <pre>let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
if (&lt; 2015) {
                alert( 'Это слишком рано...' );
              } else if (year &gt; 2015) {
                                          alert('Это поздновато' );
                                         } else {
                                                 alert( 'Верно!' );
                                          }</pre>
                    <p>У наведеному вище коді JavaScript спочатку перевірить <code>year &lt; 2015</code>. Якщо це не так, він переходить до наступного умові <code>year &gt; 2015</code>.Якщо воно теж помилково, тоді спрацює останній <code>alert</code>.</p>
                    <p>Блоков <code>else if</code> може бути і більше. Присутність блоку <code> else </code> не є обов'язковим.</p>
                    <h2><a class="main__anchor" name="uslovnyy-operator" href="#uslovnyy-operator">Умовний оператор „?“</a></h2><p>Іноді нам потрібно визначити змінну в залежності від умови.</p>
                    <p>Наприклад:</p>
                    <pre>let accessAllowed;
let age = prompt('Сколько вам лет?', '');
<em>if (age &gt; 18) { accessAllowed = true;} else {accessAllowed = false;}</em>
alert(accessAllowed);</pre>
                    <p>Так званий «умовний» оператор «знак питання» дозволяє нам зробити це більш коротким і простим способом. </p>
                    <p>Оператор представлений знаком питання <code>?</code>. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.</p>
                    <p>Синтаксис:</p>
                    <pre>let result = умова? значення 1 : значення2;</pre>
                    <p>Спочатку обчислюється <code>умова</code>: якщо воно істинне, тоді повертається <code>значення1</code>, в іншому випадку - <code>значення2</code>.</p>
                    <p>Наприклад:</p>
                     <pre>let accessAllowed = (age &gt; 18) ? true : false;</pre>
                    <p>Технічно, ми можемо опустити круглі дужки навколо<code>age &gt; 18</code>. Оператор знаку має низький пріоритет, тому він виконується після порівняння <code>&gt;</code>.</p>
                    <p>Цей приклад буде робити те ж саме, що і попередній:</p>
                    <pre>// оператор порівняння "age &gt; 18" виконується першим в будь-якому випадку
// (немає необхідності укладати його в дужки)
let accessAllowed = age &gt; 18 ? true : false;</pre>
                   <p>Але дужки роблять код більш читабельним, тому ми рекомендуємо їх використовувати.</p>
                    <div class="important__header"><span class="important__type">На заметку:</span></div>
                       <p>В наведеному вище прикладі ви можете уникнути використання оператора знаку <code>?</code>, тому що порівняння само по собі вже повертає<code>true/false</code>:</p>
                        <pre>// то же самое
let accessAllowed = age &gt; 18;</pre>
                    <h2><a class="main__anchor" name="neskolko-operatorov" href="#neskolko-operatorov">Кілька операторів "?" </a></h2><p> Послідовність операторів знаку <code>?</code> дозволяє повернути значення, яке залежить від більш ніж однієї умови.</p>
                    <p>Наприклад:</p>
                    <pre>let age = prompt('Возраст?', 18);
let message = (age &lt; 3) ? 'Здравствуй, малыш!' :
              (age &lt; 18) ? 'Привет!' :
              (age &lt; 100) ? 'Здравствуйте!' :>
              'Какой необычный возраст!';
alert( message );</pre>
                    <p>Спочатку може бути складно зрозуміти, що відбувається. Але при найближчому розгляді ми бачимо, що це звичайна послідовна перевірка:</p>
                    <ol>
                        <li>Перший знак питання перевіряє <code>age &lt; 3</code>.</li>
                        <li>Якщо вірно - повертає <code>'Здравствуй, малыш!'</code>. В іншому випадку, перевіряє вираз після двокрапки "": "", обчислює <code>age &lt; 18</code>.</li>
                        <li>Якщо це вірно - повертає <code>'Привет!'</code>. В іншому випадку, перевіряє вираз після наступного двокрапки "": "", обчислює <code>age &lt; 100</code>.</li>
                        <li>Якщо це вірно - повертає <code>'Здравствуйте!'</code>. В іншому випадку, повертає вираз після останнього двокрапки – <code>'Який незвичайний вік!'</code>.</li>
                    </ol>
                    <p>Ось як це виглядає при використанні <code>if..else</code>:</p>
                    <pre>if (age &lt; 3) {
  message = 'Здравствуй, малыш!';
} else if (age &lt; 18) {
  message = 'Привет!';
} else if (age &lt; 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}</pre>
                     <h2><a class="main__anchor" name="netraditsionnoe-ispolzovanie" href="#netraditsionnoe-ispolzovanie">Нетрадиційне використання "?" </a></h2><p> Іноді оператор «знак питання» <code>?</code> використовується в якості заміни <code>if</code>:</p>
                    <pre>let company = prompt('Какая компания создала JavaScript?', '');
<em>(company == 'Netscape') ?
alert('Верно!') : alert('Неправильно.');</em></pre>
                    <p>Залежно від умови <code>company == 'Netscape'</code>, буде виконана або перша, або друга частина після <code>?</code>. </p>
                    <p>Тут ми не присвоюємо результат змінної. Замість цього ми виконуємо різний код в залежності від умови. </p>
                    <p><strong> Не рекомендується використовувати оператор знаку таким чином. </strong> </p>
                    <p>Незважаючи на те, що такий запис коротше, ніж еквівалентна інструкція <code>if</code>, вона менш читабельна. </p>
                    <p>Ось, для порівняння, той же код, який використовує <code>if</code>:</p>
                    <pre>let company = prompt('Какая компания создала JavaScript?', '');
<em>if (company == 'Netscape') {
                                alert('Верно!');
                               } else {
                                 alert('Неправильно.');
                               }</em></pre>
                    <p>При читанні очі сканують код по вертикалі. Блоки коду, що займають кілька рядків, сприймаються набагато легше, ніж довгий горизонтальний набір інструкцій. </p>
                    <p>Сенс оператора «знак питання» <code>?</code> - повернути ту чи іншу значення, в залежності від умови. Будь ласка, використовуйте його саме для цього. Коли вам потрібно виконати різні гілки коду - використовуйте <code>if</code>.</p>
             
                <h3 id='logicalOperators'>Логічні оператори</h3>
               
                    <p>В JavaScript є три логічних оператора: <code>||</code> (ИЛИ), <code>&amp;&amp;</code> (И) и <code>!</code> (НЕ).</p>
                    <p>Незважаючи на свою назву, дані оператори можуть застосовуватися до значень будь-яких типів. Отримані результати також можуть мати різний тип. </p>
                    <p> Давайте розглянемо їх докладніше.</p>
                    <h2><a class="main__anchor" name="ili" href="#ili">|| (ИЛИ)</a></h2><p>Оператор «ИЛИ» виглядає як подвійний символ вертикальної риски:</p>
                    <pre>result = a || b;</pre>
                    <p>Традиційно в програмуванні ИЛИ призначене тільки для маніпулювання булеві значеннями: в разі, якщо який-небудь з аргументів <code>true</code>, він поверне <code>true</code>, в протилежній ситуації повертається <code>false</code>. </p>
                    <p> В JavaScript, як ми побачимо далі, цей оператор працює дещо в інший спосіб. Але давайте спершу подивимося, що відбувається з булевими значеннями. </p>
                    <p> Існує всього чотири можливі логічні комбінації:</p>
                    <pre>alert( true || true );   // true
alert( false || true );  // true
alert( true || false ); // true
alert( false || false ); // false</pre>
                    <p>Як ми можемо спостерігати, результат операцій завжди дорівнює <code>true</code>, за винятком випадку, коли обидва аргументи <code>false</code>. </p>
                    <p>Якщо значення НЕ логічного типу, то воно до нього наводиться в цілях обчислень. </p>
                    <p>Наприклад, число <code>1</code> буде сприйнято як <code>true</code>, а <code>0</code> – як <code>false</code>:</p>
                    <pre>
                    if (1 || 0) { // работает как if( true || false )
                                       alert( 'truthy!' );
                                 }</pre>
                    <p>Зазвичай оператор <code>||</code> використовується у <code>if</code> для перевірки істинності будь-якого із заданих умов.</p>
                    <p>Наприклад:</p>
                    <pre>let hour = 9;
<em>if (hour &lt; 10 || hour &gt; 18) {</em>alert( 'Офис закрыт.' );}</pre>
                   <p>Можна передати і більше умов:</p>
                   <pre>let hour = 12;
let isWeekend = true;
if (hour &lt; 10 || hour &gt; 18 || isWeekend) {alert( 'Офис закрыт.' ); // это выходной}</pre>
                     <h2><a class="main__anchor" name="ili-nahodit-pervoe-istinnoeznachenie" href="#ili-nahodit-pervoe-istinnoeznachenie">ИЛИ «||» знаходить перше справжнє&nbsp;значення</a></h2><p>Описана вище логіка відповідає традиційній. Тепер давайте попрацюємо з «додатковими» можливостями JavaScript.</p>
                    <p>Розширений алгоритм працює наступним чином. </p>
                    <p> При виконанні || з декількома значеннями:</p>
                    <pre>result = value1 || value2 || value3;</pre>
                    <p>Оператор <code>||</code> виконує наступні дії:</p>
                    <ul>
                        <li>Обчислює операнди зліва направо. </li>
                        <li>Кожен операнд конвертує в логічне значення. Якщо результат <code>true</code>, зупиняється і повертає початкове значення цього операнда. </li>
                        <li>Якщо всі операнди є помилковими (<code>false</code>), повертає останній з них. </li>
                    </ul>
                    <p> Значення повертається в початковому вигляді, без перетворення. </p>
                    <p> Іншими словами, ланцюжок  <code>"||"</code> повертає перше справжнє значення або останню, якщо таке значення не знайдено.</p>
                    <p>Наприклад:</p>
                    <pre>alert(1 || 0 ); // 1
alert( true || 'no matter what' ); // true
alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 );// 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)</pre>
                    <p>Це робить можливим більш цікаве застосування оператора в порівнянні з «чистим, традиційним, тільки булевих ИЛИ».</p>
                    <ol>
                        <li>
                            <p><strong>Отримання першого справжнього значення зі списку змінних або виразів. </strong> </p>
                            <p> Уявімо, що у нас є ряд змінних, які можуть містити дані або бути <code> null / undefined </code>. Як ми можемо знайти першу змінну з даними? </p>
                            <p> За допомогою <code>||</code>:</p>
                            <pre>let currentUser = null;
let defaultUser = "John";
<em>let name= currentUser || defaultUser || "unnamed";</em>
alert( name ); // выбирается "John" – первое истинное значение</pre>
                        <p>Якби і <code>currentUser</code>, і <code>defaultUser</code> були помилковими, як результат ми б спостерігали <code>"unnamed"</code>.</p>
                        </li>
                        <li>
                            <p><strong>Скороченя обчислення. </strong> </p>
                            <p>Операндами можуть бути як окремі значення, так і довільні вирази. || обчислює їх зліва направо. Обчислення зупиняється при досягненні першого справжнього значення. Цей процес називається «скороченим обчисленням», оскільки другий операнд обчислюється тільки в тому випадку, якщо першого недостатньо для обчислення всього виразу. </p>
                            <p>Це добре помітно, коли вираз, вказаний в якості другого аргументу, має побічний ефект, наприклад, зміни адреси. </p>
                            <p>У наведеному нижче прикладі <code>x</code> не змінюється:</p>
                            <pre>let x;
<em>true</em> || (x = 1);
alert(x); // undefined, потому что (x = 1) не вычисляется</pre>
                            <p>Якби перший аргумент мав значення <code>false</code>, то <code>||</code> приступив би до обчислення другого і виконав операцію присвоювання:</p>
                            <pre>let x;
<em>false</em> || (x = 1);
alert(x); // 1</pre>
                            <p>Присвоєння - лише один приклад. Звичайно, можуть бути й інші побічні ефекти, які не виявляться, якщо обчислення до них не дійде. </p>
                            <p> Як ми бачимо, цей варіант використання <code>||</code> є "аналогом <code>if</code>". Перший операнд перетвориться в логічний. Якщо він вияветься хибним, починається обчислення другого. </p>
                            <p> В більшості випадків краще використовувати «звичайний» <code>if</code>, щоб полегшити розуміння коду, але іноді це може бути зручно.</p>
                        </li>
                    </ol>
                    <h2><a class="main__anchor" name="i" href="#i">&amp;&amp; (И)</a></h2><p>Оператор И пишеться як два амперсанда<code>&amp;&amp;</code>:</p>
                    <pre>result = a &amp;&amp; b;</pre>
                    <p>У традиційному програмуванні И повертає <code>true</code>, якщо обидва аргументи істинні, а інакше – <code>false</code>:</p>
                    <pre>alert( true &amp;&amp; true );   // true
alert( false &amp;&amp; true );  // false
alert( true &amp;&amp; false );  // false
alert( false &amp;&amp; false ); // false</pre>
                    <p>Приклад з <code>if</code>:</p>
                    <pre>let hour = 12;
let minute = 30;
if (hour == 12 &amp;&amp; minute == 30) {alert( 'The time is 12:30' );}</pre>
                    <p>Як і у випадку з ||, будь-яке значення допускається в якості операнда &&:</p>
                    <pre>if (1 &amp;&amp; 0) { // вычисляется как true &amp;&amp; false
                            alert( "не спрацює, тому що результат помилковий" );
                           }</pre>
                    <h2><a class="main__anchor" name="i-nahodit-pervoe-lozhnoeznachenie" href="#i-nahodit-pervoe-lozhnoeznachenie">"И" «&amp;&amp;» знаходить перше помилкове&nbsp;значення</a></h2><p>При декількох підряд операторах &&:</p>
                    <pre>result = value1 &amp;&amp; value2 &amp;&amp; value3;</pre>
                    <p>Оператор <code>&amp;&amp;</code> виконує наступні дії:</p>
                    <ul>
                        <li>Обчислює операнди зліва направо. </li>
                        <li> Кожен операнд перетворює в логічне значення. Якщо результат <code>false</code>, зупиняється і повертає початкове значення цього операнда. </li>
                        <li> Якщо все операнди були справжніми, повертається останній.</li>
                    </ul>
                    <p>Іншими словами, І повертає перше помилкове значення. Або останнім, якщо нічого не знайдено. </p>
                    <p>Вищевказані правила схожі з поведінкою ИЛИ. Різниця в тому, що И повертає на початок <em> помилкове </em> значення, а ИЛИ - перша <em> справжнє </em>. </p>
                    <p>Приклади:</p>
                    <pre>// Если первый операнд истинный,
// И возвращает второй:
alert( 1 &amp;&amp; 0 ); // 0
alert( 1 &amp;&amp; 5 ); // 5
// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null &amp;&amp; 5 ); // null
alert(0 &amp;&amp; "no matter what" ); // 0</pre>
                     <p>Можна передати кілька значень поспіль. В такому випадку повернеться перше «хибне» значення, на якому зупинилися обчислення.</p>
                     <pre class="line-numbers  language-javascript"><span class="line-numbers-rows"><span></span></span><code class=" language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span></code></pre>
                     <p>Коли все значення вірні, повертається останнім</p>
                     <pre class="line-numbers  language-javascript"><span class="line-numbers-rows"><span></span></span><code class=" language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></code></pre>
                      <div class="important__header"><span class="important__type">Пріоритет оператора <code>&amp;&amp;</code> більше, ніж у <code>||</code></span></div>
                        <div class="important__content">
                            <p>Пріоритет оператора И <code>&amp;&amp;</code> більше, ніж ИЛИ <code>||</code>, так що він виконується раніше.</p>
                            <p>Таким чином, код <code>a &amp;&amp; b || c &amp;&amp; d</code> по суті такий же, як якби вираження <code>&amp;&amp;</code> були в круглих дужках: <code>(a &amp;&amp; b) || (c &amp;&amp; d)</code>.</p>
                        </div>
                    <p>Як і оператор ИЛИ, И <code>&amp;&amp;</code> іноді може замінювати <code>if</code>.</p>
                    <p>Наприклад:</p>
                    <pre>let x = 1;
(x &gt; 0) &amp;&amp; alert('Greater than zero!');</pre>
                    <p>Дія в правій части <code>&amp;&amp;</code> виконується тільки в тому випадку, якщо до неї дійдуть обчислення. Тобто, <code>alert</code> спрацює, якщо в лівій частині (<code>x &gt; 0)</code> буде <code>true</code>.</p>
                    <p>Вийшов аналог:</p>
                    <pre>let x = 1;
if (x &gt; 0) {alert( 'Greater than zero!' );}</pre>
                    <p>Однак, як правило, варіант з <code>if</code> краще читається і сприймається.</p>
                    <p>Він більш очевидний, тому краще використовувати його.</p>
                    <h2><a class="main__anchor" name="ne" href="#ne">! (НЕ)</a></h2><p>Оператор НЕ представлений знаком оклику <code>!</code>.</p>
                    <p>Синтаксис досить простий:</p>
                    <pre>result = !value;</pre>
                    <p>Оператор приймає один аргумент і виконує наступні дії:</p>
                    <ol>
                        <li>Спочатку наводить аргумент до логічного типу <code>true / false</code>. </li>
                        <li> Потім повертає протилежне значення.</li>
                    </ol>
                    <p>Наприклад:</p>
                    <pre>alert>(!true ); // false
alert( !0 ); // true</pre>
                    <p>Зокрема, подвійне НЕ використовують для перетворення значень до логічного типу:</p>
                    <pre>alert( !!"non-empty string" ); // true
alert( !!null ); // false</pre>
                    <p>Тобто перше НЕ перетворює значення в логічне значення і повертає зворотне, а друге НЕ знову інвертує його. В кінці ми маємо просте перетворення значення в логічне. </p>
                    <p> Є трохи більш докладний спосіб зробити те ж саме - вбудована функція <code>Boolean</code>:</p>
                    <pre>alert( Boolean("non-empty string") ); // true
alert( Boolean(null)); // false</pre>
                     <p>Пріоритет НЕ <code>!</code> є найвищим з усіх логічних операторів, тому він завжди виконується першим, перед <code>&amp;&amp;</code> или <code>||</code>.</p>
                
                <h3 id='functions'>Функции</h3>
                               
                    <p>Найчастіше нам треба повторювати одне і те ж дію в багатьох частинах програми. </p>
                    <p> Наприклад, необхідно красиво вивести повідомлення при вітанні відвідувача, при виході відвідувача з сайту, ще де-небудь. </p>
                    <p> Щоб не повторювати один і той же код в багатьох місцях, придумані функції. Функції є основними «будівельними блоками» програми. </p>
                    <p> Приклади вбудованих функцій ви вже бачили - це <code>alert (message)</code>, <code>prompt (message, default)</code> і <code>confirm (question)</code>. Але можна створювати і свої. </p>
                    <h2> <a class="main__anchor" name="obyavlenie-funktsii" href="#obyavlenie-funktsii"> Оголошення функції </a></h2><p> Для створення функцій ми можемо використовувати <em> оголошення функції</em>.</p>
                    <p>Приклад об'явлення функції:</p>
                    <pre>function showMessage() {alert( 'Всем привет!' );}</pre>
                    <p>Спочатку йде ключове слово <code>function </code>, після нього <em> ім'я функції </em>, потім список <em> параметрів </em> в круглих дужках через кому (у вищенаведеному прикладі він порожній) і, нарешті, код функції, також званий «тілом функції», всередині фігурних дужок.</p>
                    <pre>function имя(параметры) {  тело...}</pre>
                    <p>Наша нова функція може бути викликана за її імені: <code>showMessage()</code>.</p>
                    <p>Наприклад:</p>
                    <pre>function showMessage() {alert( 'Всем привет!' ); }
<em>showMessage();showMessage();</em></pre>
                    <p>Виклик <code>showMessage ()</code> виконує код функції. Тут ми бачимо повідомлення двічі. </p>
                    <p> Цей приклад явно демонструє одне з головних призначень функцій: позбавлення від дублювання коду. </p>
                    <p> Якщо знадобиться поміняти повідомлення або спосіб його виведення - досить змінити його в одному місці: в функції, яка його виводить. </p>
                    <h2> <a class="main__anchor" name="lokalnye-peremennye" href="#lokalnye-peremennye"> Локальні змінні </a></h2><p> Змінні, оголошені всередині функції, видно тільки всередині цієї функції.</p>
                    <p>Наприклад:</p>
                    <pre>function showMessage() {
<em>let message = "Привет, я JavaScript!"; // локальная переменная</em>
alert( message );
}
showMessage(); // Привет, я JavaScript!
alert( message ); // &lt;-- будет ошибка, т.к. переменная видна только внутри функции</pre>
                    <h2><a class="main__anchor" name="vneshnie-peremennye" href="#vneshnie-peremennye">Зовнішні змінні </a></h2><p> У функції є доступ до зовнішніх змінним, наприклад:</p>
                    <pre>let <em>userName</em>= 'Вася';
function showMessage() { message = 'Привет, ' + <em>userName</em>;
                        alert(message);
                       }
showMessage(); // Привет, Вася</pre>
                    <p>Функція має повний доступом до зовнішніх змінним і може змінювати їх значення.</p>
                    <p>Наприклад:</p>
                    <pre>let <em>userName</em> = 'Вася';
function showMessage() {
                        <em>userName</em> = "Петя"; // (1) изменяем значение внешней переменной
                        let message = 'Привет, ' + <em>userName</em>;
                        alert(message);
                       }
alert( userName )span class="token punctuation">; // <em>Вася</em> перед вызовом функции
showMessage();
alert( userName ); // <em>Петя</em>, значение внешней переменной было изменено функцией</pre>
                    <p>Зовнішня змінна використовується, тільки якщо всередині функції немає такої локальної.</p>
                    <p>Якщо однойменна змінна оголошується всередині функції, тоді вона перекриває зовнішню. Наприклад, в коді нижче функція використовує локальну змінну <code>userName</code>. Зовнішня буде проігнорована:</p>
                    <pre>let</span> userName = 'Вася';
function showMessage() {
<em> let userName = "Петя"; // объявляем локальную переменную</em>
let message = 'Привет, ' + userName; // <em>Петя</em>
alert(message);
}
// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();
alert(userName); //<em>Вася</em>, не изменилась, функция не трогала внешнюю переменную</pre>
                         <div class="important__header"><span class="important__type">Глобальні змінні </span> </div>
                            <p> Змінні, оголошені зовні всіх функцій, такі як зовнішня змінна <code>userName</code> в наведеному вище коді - називаються <em>глобальними</em>.</p>
                            <p> <em> Глобальні змінні </em> видимі для будь-якої функції (якщо тільки їх не перекривають однойменні локальні змінні). </p>
                            <p> Бажано зводити використання глобальних змінних до мінімуму. У сучасному коді зазвичай мало або зовсім немає глобальних змінних. Хоча вони іноді корисні для зберігання найважливіших «общепроектових» даних.</p>
                    <h2><a class="main__anchor" name="parametry" href="#parametry">Параметри</a></h2><p>Ми можемо передати всередину функції будь-яку інформацію, використовуючи параметри (також звані <em> аргументами функції</em>).</p>
                    <p>У нижчеподаному прикладі функції передаються два параметри: <code>from</code> и <code>text</code>.</p>
                    <pre>function showMessage(<em>from</em><em>, text</em>) { // аргументы: from, text
                               alert(from + ': ' + text);
                               }
<em>showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)</em></pre>
                    <p>Коли функція викликається в рядках <code>(*)</code> і <code>(**)</code>, передані значення копіюються в локальні змінні <code>from</code> і <code>text</code>. Потім вони використовуються в тілі функції. </p>
                    <p> Ось ще один приклад: у нас є змінна <code>from</code>, і ми передаємо її функції. Зверніть увагу: функція змінює значення <code>from</code>, але ця зміна не видно зовні. Функція завжди отримує тільки копію значення:</p>
                    <pre>function showMessage(from, text) {
<em>from = '*' + from + '*'; // немного украсим "from"</em>
alert( from + ': ' + text );
}

let from = "Аня";

showMessage(from,"Привет"); // *Аня*: Привет
// значение "from" осталось прежним, функция изменила значение локальной переменной
alert(from); // Аня</pre>
                    <h2>
                    <a class="main__anchor" name="parametry-po-umolchaniyu" href="#parametry-po-umolchaniyu">Параметри за замовчуванням </a>
                    </h2><p> Якщо параметр не вказано, то його значенням стає <code>undefined</code>. </p>
                    <p>Наприклад, вищезгадана функція <code>showMessage (from, text)</code> може бути викликана з одним аргументом:</p>
                    <pre>showMessage("Аня");</pre>
                    <p>Це не призведе до помилки. Такий виклик виведе <code>"Аня: undefined"</code>. У виклику не вказано параметр <code>text</code>, тому передбачається, що <code>text === undefined</code>. </p>
                    <p> Якщо ми хочемо задати параметру <code>text</code> значення за замовчуванням, ми повинні вказати його після <code>=</code>:</p>
                    <pre>function showMessage(from, <em>text= "текст не добавлен"</em>) {
                                alert( from+ ": " + text );
                                 }
showMessage("Аня"); // Аня: текст не добавлен</pre>
                    <p>Тепер, якщо параметр <code>text</code> не вказано, його значенням буде <code>"текст не додано"</code> </p>
                    <p> В даному випадку <code>"текст не додано"</code> це рядок, але на її місці могло б бути і більш складне вираз, яке б обчислювалося і присвоювалося при відсутності параметра. наприклад:</p>
                    <pre>function showMessage(from, text = anotherFunction()) {
                                // anotherFunction() выполнится только если не передан text
                                // результатом будет значение text
                                }</pre>
                        <div class="important__header"><span class="important__type">Обчислення параметрів за замовчуванням</span></div>
                           <p>В JavaScript параметри за замовчуванням обчислюються кожен раз, коли функція викликається без відповідного параметра.</p>
                           <p>В прикладі више <code>anotherFunction()</code> буде викликатися кожен раз, коли <code>showMessage()</code> викликається без параметра<code>text</code>.</p>
                        <div class="important__header"><span class="important__type">Використання параметрів за замовчуванням в ранніх версіях JavaScript</span></div>
                        <p>Ранні версії JavaScript не підтримували параметри за замовчуванням. Тому існують альтернативні способи, які можуть зустрічатися в старих скриптах.</p>
                            <p>Наприклад, явна перевірка на <code>undefined</code>:</p>
                            <pre>function showMessage(from, text) {
<em>if (text === undefined) {
    text = 'текст не добавлен';}</em>

alert( from + ": " + text );
}</pre>
                                <p>…Або за допомогою оператора <code>||</code>:</p>
                                <pre>function showMessage(from, text){
                                        // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
  text = text || 'текст не добавлен';
                                          ...
}</pre>
                    <h2><a class="main__anchor" name="vozvrat-znacheniya" href="#vozvrat-znacheniya">Возврат значення</a></h2><p>Функція може повернути результат, який буде переданий в який викликав її код.</p>
                    <p>Найпростішим прикладом може служити функція складання двох чисел:</p>
                    <pre>function sum(a, b) {<em>return</em> a + b;}
let result = sum(1, 2);
alert( result ); // 3</pre>
                    <p>Директива <code>return</code> може знаходитися в будь-якому місці тіла функції. Як тільки виконання доходить до цього місця, функція зупиняється, і значення повертається в який викликав її код (присвоюється змінної <code>result</code> више).</p>
                    <p> Викликів <code>return</code> може бути кілька, наприклад:</p>
                    <pre>function checkAge(age) { if (age &gt; 18){ <em>return true;</em>} else { <em>return confirm('А родители разрешили?');</em>}}
let age = prompt('Сколько вам лет?', 18);
if (checkAge(age)) { alert( 'Доступ получен' );} else {alert( 'Доступ закрыт' );}</pre>
                    <p>Можливо використовувати <code>return</code> і без значення. Це призведе до негайного виходу з функції.</p>
                    <p>Наприклад:</p>
                    <pre>function showMovie(age) {
                                if( !checkAge(age) ) {<em>return;</em>}
                                alert( "Вам показывается кино" ); // (*)
                                // ...}</pre>
                     <p> У коді вище, якщо <code>checkAge(age)</code> вернёт <code>false</code>, <code>showMovie</code> не виконає <code>alert</code>.</p>
                     <div class="important__header"><span class="important__type">Результат функції з порожнім <code>return</code> або без нього – <code>undefined</code></span></div>
                     <p>Якщо функція не повертає значення, це все одно, як якщо б вона повертала <code>undefined</code>:</p>
                     <pre>doNothing() { /* пусто */}
alert( doNothing() === undefined ); // true</pre>
                            <p>Пустой <code>return</code> аналогичен <code>return undefined</code>:</p>
                            <pre>function doNothing() {return;}
alert( doNothing() === undefined ); // true</pre>
                                    
                        <div class="important__header"><span class="important__type">Ніколи не додавайте новий рядок між <code>return</code> и его значением</span></div>
                        <p>Для довгого вираження в <code>return</code> може бути заманливо розмістити його на кількох окремих рядках, наприклад так:</p>
                        <pre>return(some + long + expression + or + whatever * f(a) + f(b)=)</pre>
                        <p>Код не виконається, тому що інтерпретатор JavaScript підставить крапку з комою після<code>return</code>. Для нього це буде виглядати так:</p>
                        <pre>return;
 (some + long + expression + or + whatever * f(a) + f(b))</pre>
                            <p>Таким чином, це фактично стало порожнім <code>return</code>.</p>
                            <p>Якщо ми хочемо, щоб повертається вираз займало кілька рядків, потрібно почати його на тому ж рядку, що і <code>return</code>. Або, хоча б, поставити там відкриває дужку, ось так:</p>
                            <pre>return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )</pre>
                            <p>І тоді все спрацює, як задумано.</p>
                 
                    <h2><a class="main__anchor" name="function-naming" href="#function-naming">Вибір імені функції </a></h2><p> Функція - це дія. Тому ім'я функції зазвичай є дієсловом. Воно повинно бути простим, точним і описувати дію функції, щоб програміст, який буде читати код, отримав вірне уявлення про те, що робить функція. </p>
                    <p> Як правило, використовуються дієслівні префікси, що позначають загальний характер дії, після яких слід уточнення. Зазвичай в командах розробників діють угоди, що стосуються значень цих префіксів. </p>
                    <p> Наприклад, функції, що починаються з <code>"show"</code> зазвичай щось показують.</p>
                    <p>Функции, начинающиеся с…</p>
                    <ul>
                        <li><code>"get…"</code> – возвращают значение,</li>
                        <li><code>"calc…"</code> – что-то вычисляют,</li>
                        <li><code>"create…"</code> – что-то создают,</li>
                        <li><code>"check…"</code> – что-то проверяют и возвращают логическое значение, и т.д.</li>
                    </ul>
                    <p>Приклади таких імен:</p>
                    <pre>showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false</pre>
                    <p>Завдяки префіксам, при першому погляді на ім'я функції стає зрозумілим що робить її код, і яке значення вона може повертати.</p>
                    <div class="important__header"><span class="important__type">Одна функція - одна дія</span></div>
                            <p>Функція повинна робити тільки те, що явно мається на увазі її назвою. І це повинно бути одним дією. <p>
                            <p> Два незалежних дії зазвичай мають на увазі дві функції, навіть якщо передбачається, що вони будуть викликатися разом (в цьому випадку ми можемо створити третю функцію, яка буде їх викликати). </p>
                            <p> Кілька прикладів, які порушують це правило:</p>
                            <ul>
                                <li><code>getAge</code> – буде поганим вибором, якщо функція буде виводити <code>alert</code> з віком (повинна тільки повертати його). </li>
                                <li> <code>createForm</code> - буде поганим вибором, якщо функція буде змінювати документ, додаючи форму в нього (має тільки створювати форму і повертати її). </li>
                                <li> <code>checkPermission</code> - буде поганим вибором, якщо функція буде відображати повідомлення з текстом <code>доступ дозволений / заборонений</code> (повинна тільки виконувати перевірку і повертати її результат). </li>
                            </ul>
                            <p> В цих прикладах використовувалися загальноприйняті смисли префіксів. Звичайно, ви в команді можете домовитися про інші значеннях, але зазвичай вони мало відрізняються від загальноприйнятих. У будь-якому випадку ви і ваша команда повинні точно розуміти, що означає префікс, що функція з ним може робити, а чого не може.</p>
                   
                        <div class="important__header"><span class="important__type">Надкороткі імена функцій</span></div>
                            <p>Імена функцій, які використовуються <em> дуже часто </em>, іноді роблять надкоротких.</p>
                            <p>Наприклад, у фреймворку <a href="http://jquery.com"> jQuery </a> є функція з ім'ям<code>$</code>. В библиотеке <a href="http://lodash.com/">Lodash</a> основна функція представлена ім'ям <code>_</code>.</p>
                            <p>Це виключення. В основному імена функцій повинні бути в міру короткими і описовими.</p>
                
                    <h2><a class="main__anchor" name="funktsii-kommentarii" href="#funktsii-kommentarii">Функції == Комментарі</a></h2><p>Функції повинні бути короткими і робити тільки щось одне. Якщо це щось велике, має сенс розбити функцію на кілька менших. Іноді дотримуватися цього правила непросто, але це безперечно гарне правило. </p>
                    <p> Невеликі функції не тільки полегшують тестування і налагодження - саме існування таких функцій виконує роль хороших коментарів!</p>
                    <p>Наприклад, порівняємо нижче дві функції <code>showPrimes(n)</code>. Кажна з них виводить <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE">просте число</a> до <code>n</code>.</p>
                    <p>Перший варіант використовує мітку <code>nextPrime</code>:</p>
                    <pre>functionshowPrimes(n) {nextPrime: for (let i = 2; i&lt; n;i++) {
                                for (let j = 2; j &lt; i; j++) {
                                if (i % j == 0) continue nextPrime;
                                }

                                alert( i ); // простое
                                }
}</pre>
                    <p> Другий варіант використовує додаткову функцію <code>isPrime (n)</code> для перевірки на просте:</p>
                    <pre>function showPrimes(n) {
                                for (let i = 2; i &lt; n; i++) {
                                <em>if (!isPrime(i)) continue>;</em>
                                alert(i); // простое
                                }
}

function isPrime(n) {
                     for (let i = 2; i &lt; n; i++) {
                     if ( n % i == 0) return false;
                    }
                     return true;
}</pre>
                    <p>Другий варіант легше для розуміння, чи не так? Замість шматка коду ми бачимо назву дії (<code>isPrime</code>). Іноді розробники називають такий код <em>самодокументіруемим</em>. </p>
                    <p>Таким чином, допустимо створювати функції, навіть якщо ми не плануємо повторно використовувати їх. Такі функції структурують код і роблять його більш зрозумілим. </p>
                    <h2> <a class="main__anchor" name="itogo" href="#itogo"> Разом </a> </h2>
                    <p> Оголошення функції має вигляд:</p>
                    <pre>function имя(параметры, через, запятую) {/* тело, код функции */}</pre>
                        <ul>
                        <li>Передані значення копіюються в параметри функції і стають локальними змінними. </li>
                        <li> Функції мають доступ до зовнішніх змінним. Але це працює тільки зсередини назовні. Код поза функції не має доступу до її локальних змінних. </li>
                        <li> Функція може повертати значення. Якщо цього не відбувається, тоді результат дорівнює <code>undefined</code>. </li>
                    </ul>
                    <p> Для того, щоб зробити код більш чистим і зрозумілим, рекомендується використовувати локальні змінні і параметри функцій, не користуватися зовнішніми змінними. </p>
                    <p> Функція, яка отримує параметри, працює з ними і потім повертає результат, набагато зрозуміліше функції, що викликається без параметрів, але змінює зовнішні змінні, що загрожує побічними ефектами. </p>
                    <p> Іменування функцій: </p>
                    <ul>
                        <li> Ім'я функції має зрозуміло і чітко відображати, що вона робить. Побачивши її виклик в коді, ви повинні тут же розуміти, що вона робить, і що повертає. </li>
                        <li> Функція - це дія, тому її ім'я зазвичай є дієсловом. </li>
                        <li> Є багато загальноприйнятих префіксів, таких як: <code>create ...</code>, <code>show ...</code>, <code>get ...</code>, <code>check ...</code> і т.д. Користуйтеся ними як підказками, що пояснюють, що робить функція. </li>
                    </ul>
                    <p> Функції є основними будівельними блоками скриптів. Ми розглянули лише основи функцій в JavaScript, але вже зараз можемо створювати і використовувати їх. Це тільки початок шляху. Ми будемо неодноразово повертатися до функцій і вивчати їх все більше і більше глибоко.</p>
                </div>

                <h3 id='control-tasks'>Контрольні питання:</h3>

                <p class='bolder'>1. У чому різниця між null та undefined?</p>
                <p class='bolder'>2. Для чого використується оператор "&&"?</p>
                <p class='bolder'>3. Для чого використується оператор "||"?</p>
                <p class='bolder'>4. Чи є використання унарного плюса (оператор "+") найшвидшим способом перетворення рядка в число?</p>
                <p class='bolder'>5. Що виведе цей код?</p><pre>   alert(20e-1['toString']);</pre>
                <p class='bolder'>6. Що робить оператор **?</p>
                <p class='bolder'>7. Чому дорівнює сумма [] + 1 + 2?</p>
                <p class='bolder'>8. Що вийде, якщо додати true + false?</p>
                <p class='bolder'>9. Що виведе цей код?</p><em><pre>   function User() { }
   User.prototype = { admin: false };
   let user = new User();
   User.prototype = { admin: true };
   alert(user.admin);</pre></em>
                <p class='bolder'>10. Що виведе цей код?</p><em><pre>   let y = 1;
   let x = y = 2;
   alert(x);</pre></em>
                <p class='bolder'>11. Чому дорівнює a + b + c?</p><em><pre>   let a = 1;
   let b = { toString() {return '1'} };
   let c = 1;</pre></em>
                <p class='bolder'>12. Чому дорівнює результат визову в цьому прикладі?</p><em><pre>  function f() {
     let a = 5;
     return new Function('b', 'return a + b');
     }
     alert( f()(1) );</pre></em>
                <p class='bolder'>13. Які конструкції для циклів є в javascript?</p>
                <p class='bolder'>14. Чому дорівнює <b>i</b> в конці коду?</p><em><pre>   for(let i=0; i<10; i++) {
    console.log(i);}                   
    // i = ?</pre></em>
                <p class='bolder'>15. Чому дорівнює змінна name?</p><em><pre>   let name = "пупкин".replace("п", "д")</pre></em>
            </div>
        </div>
    </div>
</div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
            integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
            crossorigin="anonymous"></script>
    <script src='script.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>